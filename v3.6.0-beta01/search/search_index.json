{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"IoT Hub Portal \u00b6 This project aims to provide a solution for handling IoT Devices easily. It leverages on Azure IoT Hub for connectivity and device management. Features \u00b6 Portal Authentication IoT Device & device Model management IoT Edge device management C2D Methods LoRA WAN device connectivity Prerequisites \u00b6 The following should be completed before proceeding with the IoT Hub Portal development or deployment in your environment. You must have an Azure subscription. Get an Azure Free account to get started. You must have configured an Azure AD B2C Tenant with applications. See Portal AD applications configuration page. Understand how IoTEdge LoraWAN StarterKit work. Have a look at https://azure.github.io/iotedge-lorawan-starterkit to get started. Quick Start \u00b6 Deployed Azure Resources \u00b6 The template will deploy in your Azure subscription the Following resources: IoT Hub Azure Function and Consumption Service Plan Redis Cache Application Insights Log Analytics (when opted in to use Azure Monitor) Azure WebApp and Service Plan Azure Database for PostgreSQL Instructions \u00b6 Choose a solution prefix for your deployment. Use Portal AD applications configuration page to configure your AD B2C Tenant. > You should have recorded the following information: > > * OpenID authority: <your-openid-authority> > * OpenID metadata URL: <your-openid-provider-metadata-url> > * Client ID: <your-client-id> > * API Client ID: <your-client-id> Press on the button here below to start your Azure Deployment. You will get to a page asking you to fill the following fields : Resource Group : A logical \"folder\" where all the template resource would be put into, just choose a meaningful name. Location : In which Azure Region the resources should be deployed. Make sure to choose a location where IoT Hub is available Unique Solution Prefix : A string that would be used as prefix for all the resources name to ensure their uniqueness. PostgreSQL user : The PostgreSQL user name to be used for the IoT Hub Portal database. PostgreSQL password : The PostgreSQL password to be used for the IoT Hub Portal database. Confirm PostgreSQL password : The PostgreSQL password to be used for the IoT Hub Portal database. Open Id Authority : The OpenID authority used by the portal. OpenId Metadata URL : The OpenID metadata URL used by the portal. Client Id : the ID of the web client that will be used to authenticate the portal. Api Client Id : the ID of the API client that will be used to authenticate the portal. Edge gateway name : the name of your LoRa Gateway node in the IoT Hub. Deploy Device : Do you want demo end devices to be already provisioned (one using OTAA and one using ABP)? If yes set this to true, the code located in the Arduino folder would be ready to use immediately. Reset pin : The reset pin of your gateway (the value should be 7 for the Seed Studio LoRaWan, 25 for the IC880A) Region : In what region are you operating your device (currently only EU868 and US915 is supported) see: https://azure.github.io/iotedge-lorawan-starterkit/dev/quickstart/#deployed-azure-infrastructure for more information about the LoRaWan IoT Hub and Azure deployment. Known Issues and Limitations \u00b6 Refer to Known Issues for known issues, gotchas and limitations. Support \u00b6 This is an open source solution. For bugs and issues with the codebase please log an issue in this repo. Credits \u00b6 Azure IoT Edge LoRaWAN Starter Kit","title":"IoT Hub Portal"},{"location":"#iot-hub-portal","text":"This project aims to provide a solution for handling IoT Devices easily. It leverages on Azure IoT Hub for connectivity and device management.","title":"IoT Hub Portal"},{"location":"#features","text":"Portal Authentication IoT Device & device Model management IoT Edge device management C2D Methods LoRA WAN device connectivity","title":"Features"},{"location":"#prerequisites","text":"The following should be completed before proceeding with the IoT Hub Portal development or deployment in your environment. You must have an Azure subscription. Get an Azure Free account to get started. You must have configured an Azure AD B2C Tenant with applications. See Portal AD applications configuration page. Understand how IoTEdge LoraWAN StarterKit work. Have a look at https://azure.github.io/iotedge-lorawan-starterkit to get started.","title":"Prerequisites"},{"location":"#quick-start","text":"","title":"Quick Start"},{"location":"#deployed-azure-resources","text":"The template will deploy in your Azure subscription the Following resources: IoT Hub Azure Function and Consumption Service Plan Redis Cache Application Insights Log Analytics (when opted in to use Azure Monitor) Azure WebApp and Service Plan Azure Database for PostgreSQL","title":"Deployed Azure Resources"},{"location":"#instructions","text":"Choose a solution prefix for your deployment. Use Portal AD applications configuration page to configure your AD B2C Tenant. > You should have recorded the following information: > > * OpenID authority: <your-openid-authority> > * OpenID metadata URL: <your-openid-provider-metadata-url> > * Client ID: <your-client-id> > * API Client ID: <your-client-id> Press on the button here below to start your Azure Deployment. You will get to a page asking you to fill the following fields : Resource Group : A logical \"folder\" where all the template resource would be put into, just choose a meaningful name. Location : In which Azure Region the resources should be deployed. Make sure to choose a location where IoT Hub is available Unique Solution Prefix : A string that would be used as prefix for all the resources name to ensure their uniqueness. PostgreSQL user : The PostgreSQL user name to be used for the IoT Hub Portal database. PostgreSQL password : The PostgreSQL password to be used for the IoT Hub Portal database. Confirm PostgreSQL password : The PostgreSQL password to be used for the IoT Hub Portal database. Open Id Authority : The OpenID authority used by the portal. OpenId Metadata URL : The OpenID metadata URL used by the portal. Client Id : the ID of the web client that will be used to authenticate the portal. Api Client Id : the ID of the API client that will be used to authenticate the portal. Edge gateway name : the name of your LoRa Gateway node in the IoT Hub. Deploy Device : Do you want demo end devices to be already provisioned (one using OTAA and one using ABP)? If yes set this to true, the code located in the Arduino folder would be ready to use immediately. Reset pin : The reset pin of your gateway (the value should be 7 for the Seed Studio LoRaWan, 25 for the IC880A) Region : In what region are you operating your device (currently only EU868 and US915 is supported) see: https://azure.github.io/iotedge-lorawan-starterkit/dev/quickstart/#deployed-azure-infrastructure for more information about the LoRaWan IoT Hub and Azure deployment.","title":"Instructions"},{"location":"#known-issues-and-limitations","text":"Refer to Known Issues for known issues, gotchas and limitations.","title":"Known Issues and Limitations"},{"location":"#support","text":"This is an open source solution. For bugs and issues with the codebase please log an issue in this repo.","title":"Support"},{"location":"#credits","text":"Azure IoT Edge LoRaWAN Starter Kit","title":"Credits"},{"location":"b2c-applications/","text":"Azure AD B2C Tenant with applications \u00b6 This solution uses Azure AD B2C to authenticate the portal. In this page you will configure the B2C tenant and two applications (API and Web UI). By the end, you should have recorded the following information: Text Only 1 2 3 4 * OpenID authority: `<your-openid-authority>` * OpenID metadata URL: `<your-openid-provider-metadata-url>` * Client ID: `<your-client-id>` * API Client ID: `<your-client-id>` Step by Step instructions \u00b6 Create an Azure AD B2C Tenant (see: https://docs.microsoft.com/en-us/azure/active-directory-b2c/tutorial-create-tenant#create-an-azure-ad-b2c-tenant ) Record the tenant ID and the tenant name . Configure the requiered AD Applications. Create the IoT Hub Portal API Application: Select App registrations , and then select New registration . Enter a Name for the application. For example, IoT Hub Portal . Under Redirect URI , select Web , and then enter an expected endpoint for your portal (ex: https:// tenantName .b2clogin.com/ tenantName .onmicrosoft.com/oauth2/authresp ) Select Register . Record the Application (client) ID for use in your web API's code. Under Manage , select Certificates & Secrets . Under Client secret , select New client secret . Enter a name for the secret. Record the Client secret for use in your web API's code. Under Manage , select API permissions . Under Configured permissions , select Add a permission . Select the Microsoft APIs tab. Under Commonly used Microsoft APIs , select Microsoft Graph . Select Application permissions . Under Application permissions , expand User , then select: User.Invite.All User.ManageIdentities.All User.Read.All User.ReadWrite.All Select Add permission . If you're prompted to select an account, select your currently signed-in administrator account, or sign in with an account in your Azure AD B2C tenant that's been assigned at least the Cloud application administrator role. Under Manage , select Expose an API . Next to Application ID URI , select the Set link. Under Scopes defined by this API , select Add a scope . Enter the following values to create a scope that defines read access to the API, then select Add scope : Scope name : API.Access (this is the name of the scope that will be used in the template) Admin consent display name : Access to the Portal API Admin consent description : Allows the application to get access to the Portal API Create the IoT Hub Portal Client Application: Select App registrations , and then select New registration . Enter a Name for the application. For example, IoT Hub Portal Client . Under Redirect URI , select Web , and then enter an expected endpoint for your portal (ex: https://**solutionPrefix**portal.azurewebsites.net/authentication/login-callback ) Select Register . Record the Application (client) ID for use in your web client. Select App registrations , and then select the web application that should have access to the API. Under Manage , select API permissions . Under Configured permissions , select Add a permission . Select the My APIs tab. Select the API to which the web application should be granted access. Under Permission , expand API , and then select the scope that you defined earlier. Select Add permissions . Select Grant admin consent for (your tenant name) . If you're prompted to select an account, select your currently signed-in administrator account, or sign in with an account in your Azure AD B2C tenant that's been assigned at least the Cloud application administrator role. Select Yes . Select Refresh , and then verify that \"Granted for ...\" appears under Status for both scopes. Configure the required User flow: Select User flows , and then select New user flow . Under Select a user flow type , select Sign in , then select Create . Enter a name for the flow SignIn , then select Create .","title":"Azure AD B2C Tenant with applications"},{"location":"b2c-applications/#azure-ad-b2c-tenant-with-applications","text":"This solution uses Azure AD B2C to authenticate the portal. In this page you will configure the B2C tenant and two applications (API and Web UI). By the end, you should have recorded the following information: Text Only 1 2 3 4 * OpenID authority: `<your-openid-authority>` * OpenID metadata URL: `<your-openid-provider-metadata-url>` * Client ID: `<your-client-id>` * API Client ID: `<your-client-id>`","title":"Azure AD B2C Tenant with applications"},{"location":"b2c-applications/#step-by-step-instructions","text":"Create an Azure AD B2C Tenant (see: https://docs.microsoft.com/en-us/azure/active-directory-b2c/tutorial-create-tenant#create-an-azure-ad-b2c-tenant ) Record the tenant ID and the tenant name . Configure the requiered AD Applications. Create the IoT Hub Portal API Application: Select App registrations , and then select New registration . Enter a Name for the application. For example, IoT Hub Portal . Under Redirect URI , select Web , and then enter an expected endpoint for your portal (ex: https:// tenantName .b2clogin.com/ tenantName .onmicrosoft.com/oauth2/authresp ) Select Register . Record the Application (client) ID for use in your web API's code. Under Manage , select Certificates & Secrets . Under Client secret , select New client secret . Enter a name for the secret. Record the Client secret for use in your web API's code. Under Manage , select API permissions . Under Configured permissions , select Add a permission . Select the Microsoft APIs tab. Under Commonly used Microsoft APIs , select Microsoft Graph . Select Application permissions . Under Application permissions , expand User , then select: User.Invite.All User.ManageIdentities.All User.Read.All User.ReadWrite.All Select Add permission . If you're prompted to select an account, select your currently signed-in administrator account, or sign in with an account in your Azure AD B2C tenant that's been assigned at least the Cloud application administrator role. Under Manage , select Expose an API . Next to Application ID URI , select the Set link. Under Scopes defined by this API , select Add a scope . Enter the following values to create a scope that defines read access to the API, then select Add scope : Scope name : API.Access (this is the name of the scope that will be used in the template) Admin consent display name : Access to the Portal API Admin consent description : Allows the application to get access to the Portal API Create the IoT Hub Portal Client Application: Select App registrations , and then select New registration . Enter a Name for the application. For example, IoT Hub Portal Client . Under Redirect URI , select Web , and then enter an expected endpoint for your portal (ex: https://**solutionPrefix**portal.azurewebsites.net/authentication/login-callback ) Select Register . Record the Application (client) ID for use in your web client. Select App registrations , and then select the web application that should have access to the API. Under Manage , select API permissions . Under Configured permissions , select Add a permission . Select the My APIs tab. Select the API to which the web application should be granted access. Under Permission , expand API , and then select the scope that you defined earlier. Select Add permissions . Select Grant admin consent for (your tenant name) . If you're prompted to select an account, select your currently signed-in administrator account, or sign in with an account in your Azure AD B2C tenant that's been assigned at least the Cloud application administrator role. Select Yes . Select Refresh , and then verify that \"Granted for ...\" appears under Status for both scopes. Configure the required User flow: Select User flows , and then select New user flow . Under Select a user flow type , select Sign in , then select Create . Enter a name for the flow SignIn , then select Create .","title":"Step by Step instructions"},{"location":"concepts/","text":"Core Concepts \u00b6 The Azure IoT Hub portal inherits from Azure IoT Hub concepts to manage IoT devices. It relies on the following concepts: IoT Device Provisioning IoT Hub Device Twin IoT Hub Device Twin properties IoT Hub Edge deployment manifest Cloud To Device Message Device models \u00b6 By using this capability, the application can create logical representations of IoT devices. This feature is designed to configure a set of sharable properties between devices. When creating a device, the user is asked to specify the device model. The application will then apply the properties of the device model to the device. Parameters \u00b6 Device Model Id : The ID of the device model. > Note: Since the device model is shared among all the devices, theID should be unique. For convenience, the ID is generated by the application. By using the API, the ID is not required, but if provided, it will be used as the ID of the device model. Name : The name of the device model. Description : The description of the device model. Built-in models \u00b6 Built-in models are predefined device models that can be used by the application. This functionality is exactly the same as standard device models except that the properties are not editable and the device model is not removable via the Portal. Note: Creating and updating built-in models is not available in the portal. They can be managed using the Azure IoT Hub portal APIs. See Device Model API reference for more information. Devices \u00b6 Devices are the physical IoT devices that are provisioned by the application. They are represented by an object that is stored in the Azure IoT Hub as the device twin. Device Parameters \u00b6 Device Id : The ID of the device. > Note: It is the device id stored in the Azure IoT Hub. It is asked to the user when creating a device and is not editable after the device is created. Name : The name of the device model. > Note: The device name is the device friendly name. The name is editable after the device is created. Device Model : The device model that the device is based on. > Note: The device model is asked to the user during the device creation and is not editable after the device is created. Status : The status of the device. > Note: The status is related to the Device status in the Azure IoT Hub. Tags : The tags of the device. > Note: The tags are related to the Device tags in the Azure IoT Hub. They could be defined at the portal level and set to the device for filtering and targeting for configuration. Device Twin tags \u00b6 To store additional information about the device, the application uses device twin tags. Name Position Description deviceName tags.deviceName Field that contains the device friendly name. note : if not set, the portal will show the device id instead of the device name until it's configured. modelId tags.modelId Field that contains the device model identifier that the device is related. note : if not set, the device is not usable on the IoT hub portal. supportLoRaFeatures tags.supportLoRaFeatures Field that specifies if the device must support LoRa features. note : if not set, LoRa features will be available on the device. IoT Edge \u00b6 IoT Edge is fully herited from Azure IoT Hub concepts. In the portal, the user can mangage the IoT Edge devices stored in Azure IoT Hub. For more information about Azure IoT Edge, see Azure IoT Edge documentation . IoT Edge Parameters \u00b6 Type : The type of the IoT Edge device. > Note: related to the IoT Edge purpose tag value that might be used to create deployment manifests. Environment : The IoT Edge device environment (Development, Production, QA). > Note: this is an additional field that can be used to create deployment manifests. Status : The status of the device. > Note: The status is related to the Device status in the Azure IoT Hub. Nbr of connected devices : The number of devices connected to the IoT Edge device. > Note: The number of connected devices is related to the number of connections that are currently present in the edgeHub module. This might be different from the number of devices connected to the IoT Edge device if some modules are using edgeHub connections. Nbr of desired modules : The number of modules that are desired in the last deployment. Last deployment \u00b6 The last deployment section shows information about the deployment manifest that is currently applied to the IoT Edge device. IoT Edge Module \u00b6 The IoT Edge module section represents the modules that are currently deployed on the IoT Edge device. It doesn't include the system modules of IoT Edge (edgeAgent and edgeHub). With the portal, the user can interact with these modules and manage them (Get last module logs, restart module, etc.). IoT Edge Device Twin tags \u00b6 To store additional information about the device, the application uses device twin tags. Name Position Description Environment tags.env Field that contains the Device Environment value. note : this tag may be used to target deployment manifests for the IoT Edge Type tags.type Field that contains The type of the IoT Edge device. note : this tag may be used to target deployment manifests for the IoT Edge DPS Enrollment groups \u00b6 The IoT Hub portal relies on Azure Device Provisioning Enrollement groups to manage IoT Edge device connection strings. When clicking on \" Connect \" in the IoT Edge details page, the user can access the device unique credentials in the enrollment group. Note: see Provision the device with its cloud identity to know how to configure the IoT Edge to use these credentials to connect to the platform. Device Configuration \u00b6 By using the portal, users can manage the device configuration and deploy to devices that are targeted by the configuration. It relies on the Device Model to define the configuration parameters that can be deployed to the devices. Device Configuration template \u00b6 Under the cover, the configuration is stored in the Azure IoT Hub as the twin configuration. JSON 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"id\" : \"<configuration-name>-<timestamp>\" , \"schemaVersion\" : \"1.0\" , \"labels\" : { \"created-by\" : \"Azure IoT hub Portal\" , \"configuration-id\" : \"<configuration-name>\" }, \"content\" : { \"deviceContent\" : { \"properties.desired.**\" : ** } }, \"targetCondition\" : \"tags.modelId = '<The model identifier>' and tags.** = '**' AND ...\" , \"createdTimeUtc\" : \"2022-06-13T07:32:19.7376998Z\" , \"lastUpdatedTimeUtc\" : \"2022-06-13T07:32:19.7376998Z\" , \"priority\" : 100 } Please note that the created-by label is used to identify the configuration created by the IoT Hub portal. IoT Edge Configuration \u00b6 The IoT Edge configuration concerns the IoT Edge deployment manifests that are currently present in the IoT Hub. The portal can be used to see the details of the configurations. Note: At this time the portal cannot be used to update the configurations. Target \u00b6 The parameters are related to the IoT Edge deployment manifest target condition field. The IoT Hub portal will use the Target condition to extract this values from the deployment manifest. Name Position Description Owner tags.owner Owner tag filter condition from the Deployment Manifest. Environment tags.env Environment tag filter from the Deployment Manifest. Type tags.type Device type tag filter from the Deployment Manifest. Expected value for IoT Edge LoRaWAN LNS is LoRa Network Server , otherwise the value must be Other Enrollment groups \u00b6 The IoT Hub portal relies on Azure Device Provisioning Enrollment groups to manage IoT device connection credentials. For each device model, the portal will create a new enrollment group with symmetric key attestation. By clicking on \" Connect \" in the device details page, the portal will show unique credentials to the device for the corresponding enrollment group. Furthermore, the enrollment group is configured to provide initial device twin state: JSON 1 2 3 4 5 6 7 8 { \"tags\" : { \"modelId\" : \"......\" }, \"properties\" : { \"desired\" : {} } } For more information, see Azure Device Provisioning Enrollement groups . LoRaWAN \u00b6 LoRaWAN features are activated by default, providing a way to configure IoT Devices that supports LoRaWAN connectivity in the Portal. Internally, the LoRaWAN connectivity is expected to be provided by IoTEdge LoRaWAN StarterKit . The IoT Hub portal will manage devices by modifying their twin properties to make them working with this solution. Note: to disable LoRa Features, change the value of LoRaFeature__Enabled to false in the Portal App Settings. LoRaWAN Device Models \u00b6 For regular Device Models the IoT hub portal provides the possibility to manage LoRaWAN device models. To activate the LoRaWAN features on the device model, the user have to enable the option in the LoRa Device section Note: once activated, the device model detail adds a new tab called \"LORAWAN\" that adds new settings to the device model. LoRaWAN Device Model Parameters \u00b6 The parameters for the device models are parameters that are stored in the IoT Hub portal and retrieved for devices that inherits from this device model. Note: When changing the value of a parameter, the device will be updated with the new value. In that case, user should then modify each device and re-save it to get the correct properties. Support OTAA/ABP setting : The device model supports OTAA/ABP connectivity. Type : The LoRaWAN device class type (A or C). Message Deduplication : Allows controlling the handling of duplicate messages received by multiple gateways.The default is Drop. OTAA AppEUI : The device model OTAA App EUI used for the device during the OTAA Join procedure. Sensor Decoder URL : The Sensor Decoder URL that the network server should use to decode frames comming from the devices that inherit from this model. Device Connection Timeout : Allows defining a sliding expiration to the connection between the leaf device and IoT/Edge Hub. The default is none, which causes the connection to not be dropped. Support downstream messages : Allows controlling the support of downstream messages. The default is false. Preferred receive window : Allows setting the device preferred receive window (RX1 or RX2). The default preferred receive window is 1 RX Delay : Allows setting a custom wait time between receiving and transmission as specified in the specification. RX1 Data offset : Allows setting a custom data offset for the RX1 receive window. The default is 0. RX2 Data rate : Allows setting a custom data rate for the RX2 receive window. The default is 0. 32bit counter support : Allow the usage of 32bit counters on your device. Frame counter up start value : Allows setting the frame counter start value for upstream messages. The default is 0. Frame counter down start value : Allows setting the frame counter start value for downstream messages. The default is 0. Frame counter reset value : Allows to reset the frame counters to the FCntUpStart/FCntDownStart values respectively. Note: for more information about LoRaWAN properties, please refer to the LoRaWAN StarterKit Documentation Commands \u00b6 The devices commands are pre-stored frames that the user can add to the device model and then will be able to use on the device detail page to launch to the device. Name : The command name. This name is only a friendly name that the user can set to understand what the command is supposed to do. Frame : The LoRaWAN frame (in hex) to be sent to the device. LoRaWAN Devices \u00b6 LoRaWAN devices are accessible from the IoT Hub portal for devices that inherits from the LoRaWAN device model. The LoRaWAN tab shows the device details. Note: By selecting the correct device model on the first tab, the portal will automatically take LoRaWAN settings from the device model to apply on the device. Concentrators \u00b6 Concentrator Parameters \u00b6 Device ID : The Station EUI for the LoRaWan Basic station. Device Name : The friendly name for the device. Client Certificate Thumbprint : The client certificate thumbprint used by the Basic Station to authenticate to the LoRaWAN Network Server. Region : The LoRaWAN region used by the Basic Station (EU868, US915, AS923 and CN470 supported). Concentrator Tags \u00b6 To store additional information about the concentrator, the application will use the target device to extract values: Name Position Description Device Name tags.deviceName Field that contains the Device name. Region tags.loraRegion Field that contains the Device region. deviceType tags.deviceType Field that contains The type of device. Expected value is LoRa Concentrator Command Execution \u00b6 To execute the command, the device should have joined the network. The message below explains that the device have to be connected to the network ant commands are disabled until the device is connected to the network. Command execution flow \u00b6 The schema below explain how the command execution flow works. sequenceDiagram User->>+IoT Hub Portal: Send Command (DeviceId, FrameId) IoT Hub Portal->>+LoRa Key Management Facade: POST /api/cloudtodevicemessage LoRa Key Management Facade->>+Azure IoT Hub: Invoke Device Method to Network Server Azure IoT Hub-->>-LoRa Key Management Facade: Cloud To Device Method Result LoRa Key Management Facade-->>-IoT Hub Portal: Send Cloud To Device Message Result IoT Hub Portal-->>-User: Command send result See https://azure.github.io/iotedge-lorawan-starterkit/2.0.0/quickstart/#cloud-to-device-message for more information about the Cloud To Device Message involed in the LoRa WAN device commands execution flow. Automatic device configuration for LoRa WAN \u00b6 When modifying the device model, the IoT Hub portal will automatically create a new Device Configuration that will target the IoT devices that have the corresponding modelId tag. The IoT Hub portal will create a new Rollout deployment that will remove older configuration and add the new configuration. This process ensure that the devices twin will be updated at scale by the IoT hub and each devices that inherit for the model will be updated according the model configuration. The configuration will be created with the following schema: JSON 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"id\" : \"<model-name>-<timestamp>\" , \"schemaVersion\" : \"1.0\" , \"labels\" : { \"created-by\" : \"Azure IoT hub Portal\" }, \"content\" : { \"deviceContent\" : { \"properties.desired.AppEUI\" : \"<The Device Model OTAA AppEUI>\" , \"properties.desired.SensorDecoder\" : \"<The Device Model Sensor Decoder>\" } }, \"targetCondition\" : \"tags.modelId = '<The model identifier>'\" , \"createdTimeUtc\" : \"2022-02-28T20:29:39.128Z\" , \"lastUpdatedTimeUtc\" : \"2022-02-28T20:29:39.128Z\" , \"priority\" : 0 } Please note that the created-by label is used to identify the configuration created by the IoT Hub portal. For more information see Automatic IoT device and module management .","title":"Concepts"},{"location":"concepts/#core-concepts","text":"The Azure IoT Hub portal inherits from Azure IoT Hub concepts to manage IoT devices. It relies on the following concepts: IoT Device Provisioning IoT Hub Device Twin IoT Hub Device Twin properties IoT Hub Edge deployment manifest Cloud To Device Message","title":"Core Concepts"},{"location":"concepts/#device-models","text":"By using this capability, the application can create logical representations of IoT devices. This feature is designed to configure a set of sharable properties between devices. When creating a device, the user is asked to specify the device model. The application will then apply the properties of the device model to the device.","title":"Device models"},{"location":"concepts/#parameters","text":"Device Model Id : The ID of the device model. > Note: Since the device model is shared among all the devices, theID should be unique. For convenience, the ID is generated by the application. By using the API, the ID is not required, but if provided, it will be used as the ID of the device model. Name : The name of the device model. Description : The description of the device model.","title":"Parameters"},{"location":"concepts/#built-in-models","text":"Built-in models are predefined device models that can be used by the application. This functionality is exactly the same as standard device models except that the properties are not editable and the device model is not removable via the Portal. Note: Creating and updating built-in models is not available in the portal. They can be managed using the Azure IoT Hub portal APIs. See Device Model API reference for more information.","title":"Built-in models"},{"location":"concepts/#devices","text":"Devices are the physical IoT devices that are provisioned by the application. They are represented by an object that is stored in the Azure IoT Hub as the device twin.","title":"Devices"},{"location":"concepts/#device-parameters","text":"Device Id : The ID of the device. > Note: It is the device id stored in the Azure IoT Hub. It is asked to the user when creating a device and is not editable after the device is created. Name : The name of the device model. > Note: The device name is the device friendly name. The name is editable after the device is created. Device Model : The device model that the device is based on. > Note: The device model is asked to the user during the device creation and is not editable after the device is created. Status : The status of the device. > Note: The status is related to the Device status in the Azure IoT Hub. Tags : The tags of the device. > Note: The tags are related to the Device tags in the Azure IoT Hub. They could be defined at the portal level and set to the device for filtering and targeting for configuration.","title":"Device Parameters"},{"location":"concepts/#device-twin-tags","text":"To store additional information about the device, the application uses device twin tags. Name Position Description deviceName tags.deviceName Field that contains the device friendly name. note : if not set, the portal will show the device id instead of the device name until it's configured. modelId tags.modelId Field that contains the device model identifier that the device is related. note : if not set, the device is not usable on the IoT hub portal. supportLoRaFeatures tags.supportLoRaFeatures Field that specifies if the device must support LoRa features. note : if not set, LoRa features will be available on the device.","title":"Device Twin tags"},{"location":"concepts/#iot-edge","text":"IoT Edge is fully herited from Azure IoT Hub concepts. In the portal, the user can mangage the IoT Edge devices stored in Azure IoT Hub. For more information about Azure IoT Edge, see Azure IoT Edge documentation .","title":"IoT Edge"},{"location":"concepts/#iot-edge-parameters","text":"Type : The type of the IoT Edge device. > Note: related to the IoT Edge purpose tag value that might be used to create deployment manifests. Environment : The IoT Edge device environment (Development, Production, QA). > Note: this is an additional field that can be used to create deployment manifests. Status : The status of the device. > Note: The status is related to the Device status in the Azure IoT Hub. Nbr of connected devices : The number of devices connected to the IoT Edge device. > Note: The number of connected devices is related to the number of connections that are currently present in the edgeHub module. This might be different from the number of devices connected to the IoT Edge device if some modules are using edgeHub connections. Nbr of desired modules : The number of modules that are desired in the last deployment.","title":"IoT Edge Parameters"},{"location":"concepts/#last-deployment","text":"The last deployment section shows information about the deployment manifest that is currently applied to the IoT Edge device.","title":"Last deployment"},{"location":"concepts/#iot-edge-module","text":"The IoT Edge module section represents the modules that are currently deployed on the IoT Edge device. It doesn't include the system modules of IoT Edge (edgeAgent and edgeHub). With the portal, the user can interact with these modules and manage them (Get last module logs, restart module, etc.).","title":"IoT Edge Module"},{"location":"concepts/#iot-edge-device-twin-tags","text":"To store additional information about the device, the application uses device twin tags. Name Position Description Environment tags.env Field that contains the Device Environment value. note : this tag may be used to target deployment manifests for the IoT Edge Type tags.type Field that contains The type of the IoT Edge device. note : this tag may be used to target deployment manifests for the IoT Edge","title":"IoT Edge Device Twin tags"},{"location":"concepts/#dps-enrollment-groups","text":"The IoT Hub portal relies on Azure Device Provisioning Enrollement groups to manage IoT Edge device connection strings. When clicking on \" Connect \" in the IoT Edge details page, the user can access the device unique credentials in the enrollment group. Note: see Provision the device with its cloud identity to know how to configure the IoT Edge to use these credentials to connect to the platform.","title":"DPS Enrollment groups"},{"location":"concepts/#device-configuration","text":"By using the portal, users can manage the device configuration and deploy to devices that are targeted by the configuration. It relies on the Device Model to define the configuration parameters that can be deployed to the devices.","title":"Device Configuration"},{"location":"concepts/#device-configuration-template","text":"Under the cover, the configuration is stored in the Azure IoT Hub as the twin configuration. JSON 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"id\" : \"<configuration-name>-<timestamp>\" , \"schemaVersion\" : \"1.0\" , \"labels\" : { \"created-by\" : \"Azure IoT hub Portal\" , \"configuration-id\" : \"<configuration-name>\" }, \"content\" : { \"deviceContent\" : { \"properties.desired.**\" : ** } }, \"targetCondition\" : \"tags.modelId = '<The model identifier>' and tags.** = '**' AND ...\" , \"createdTimeUtc\" : \"2022-06-13T07:32:19.7376998Z\" , \"lastUpdatedTimeUtc\" : \"2022-06-13T07:32:19.7376998Z\" , \"priority\" : 100 } Please note that the created-by label is used to identify the configuration created by the IoT Hub portal.","title":"Device Configuration template"},{"location":"concepts/#iot-edge-configuration","text":"The IoT Edge configuration concerns the IoT Edge deployment manifests that are currently present in the IoT Hub. The portal can be used to see the details of the configurations. Note: At this time the portal cannot be used to update the configurations.","title":"IoT Edge Configuration"},{"location":"concepts/#target","text":"The parameters are related to the IoT Edge deployment manifest target condition field. The IoT Hub portal will use the Target condition to extract this values from the deployment manifest. Name Position Description Owner tags.owner Owner tag filter condition from the Deployment Manifest. Environment tags.env Environment tag filter from the Deployment Manifest. Type tags.type Device type tag filter from the Deployment Manifest. Expected value for IoT Edge LoRaWAN LNS is LoRa Network Server , otherwise the value must be Other","title":"Target"},{"location":"concepts/#enrollment-groups","text":"The IoT Hub portal relies on Azure Device Provisioning Enrollment groups to manage IoT device connection credentials. For each device model, the portal will create a new enrollment group with symmetric key attestation. By clicking on \" Connect \" in the device details page, the portal will show unique credentials to the device for the corresponding enrollment group. Furthermore, the enrollment group is configured to provide initial device twin state: JSON 1 2 3 4 5 6 7 8 { \"tags\" : { \"modelId\" : \"......\" }, \"properties\" : { \"desired\" : {} } } For more information, see Azure Device Provisioning Enrollement groups .","title":"Enrollment groups"},{"location":"concepts/#lorawan","text":"LoRaWAN features are activated by default, providing a way to configure IoT Devices that supports LoRaWAN connectivity in the Portal. Internally, the LoRaWAN connectivity is expected to be provided by IoTEdge LoRaWAN StarterKit . The IoT Hub portal will manage devices by modifying their twin properties to make them working with this solution. Note: to disable LoRa Features, change the value of LoRaFeature__Enabled to false in the Portal App Settings.","title":"LoRaWAN"},{"location":"concepts/#lorawan-device-models","text":"For regular Device Models the IoT hub portal provides the possibility to manage LoRaWAN device models. To activate the LoRaWAN features on the device model, the user have to enable the option in the LoRa Device section Note: once activated, the device model detail adds a new tab called \"LORAWAN\" that adds new settings to the device model.","title":"LoRaWAN Device Models"},{"location":"concepts/#lorawan-device-model-parameters","text":"The parameters for the device models are parameters that are stored in the IoT Hub portal and retrieved for devices that inherits from this device model. Note: When changing the value of a parameter, the device will be updated with the new value. In that case, user should then modify each device and re-save it to get the correct properties. Support OTAA/ABP setting : The device model supports OTAA/ABP connectivity. Type : The LoRaWAN device class type (A or C). Message Deduplication : Allows controlling the handling of duplicate messages received by multiple gateways.The default is Drop. OTAA AppEUI : The device model OTAA App EUI used for the device during the OTAA Join procedure. Sensor Decoder URL : The Sensor Decoder URL that the network server should use to decode frames comming from the devices that inherit from this model. Device Connection Timeout : Allows defining a sliding expiration to the connection between the leaf device and IoT/Edge Hub. The default is none, which causes the connection to not be dropped. Support downstream messages : Allows controlling the support of downstream messages. The default is false. Preferred receive window : Allows setting the device preferred receive window (RX1 or RX2). The default preferred receive window is 1 RX Delay : Allows setting a custom wait time between receiving and transmission as specified in the specification. RX1 Data offset : Allows setting a custom data offset for the RX1 receive window. The default is 0. RX2 Data rate : Allows setting a custom data rate for the RX2 receive window. The default is 0. 32bit counter support : Allow the usage of 32bit counters on your device. Frame counter up start value : Allows setting the frame counter start value for upstream messages. The default is 0. Frame counter down start value : Allows setting the frame counter start value for downstream messages. The default is 0. Frame counter reset value : Allows to reset the frame counters to the FCntUpStart/FCntDownStart values respectively. Note: for more information about LoRaWAN properties, please refer to the LoRaWAN StarterKit Documentation","title":"LoRaWAN Device Model Parameters"},{"location":"concepts/#commands","text":"The devices commands are pre-stored frames that the user can add to the device model and then will be able to use on the device detail page to launch to the device. Name : The command name. This name is only a friendly name that the user can set to understand what the command is supposed to do. Frame : The LoRaWAN frame (in hex) to be sent to the device.","title":"Commands"},{"location":"concepts/#lorawan-devices","text":"LoRaWAN devices are accessible from the IoT Hub portal for devices that inherits from the LoRaWAN device model. The LoRaWAN tab shows the device details. Note: By selecting the correct device model on the first tab, the portal will automatically take LoRaWAN settings from the device model to apply on the device.","title":"LoRaWAN Devices"},{"location":"concepts/#concentrators","text":"","title":"Concentrators"},{"location":"concepts/#concentrator-parameters","text":"Device ID : The Station EUI for the LoRaWan Basic station. Device Name : The friendly name for the device. Client Certificate Thumbprint : The client certificate thumbprint used by the Basic Station to authenticate to the LoRaWAN Network Server. Region : The LoRaWAN region used by the Basic Station (EU868, US915, AS923 and CN470 supported).","title":"Concentrator Parameters"},{"location":"concepts/#concentrator-tags","text":"To store additional information about the concentrator, the application will use the target device to extract values: Name Position Description Device Name tags.deviceName Field that contains the Device name. Region tags.loraRegion Field that contains the Device region. deviceType tags.deviceType Field that contains The type of device. Expected value is LoRa Concentrator","title":"Concentrator Tags"},{"location":"concepts/#command-execution","text":"To execute the command, the device should have joined the network. The message below explains that the device have to be connected to the network ant commands are disabled until the device is connected to the network.","title":"Command Execution"},{"location":"concepts/#command-execution-flow","text":"The schema below explain how the command execution flow works. sequenceDiagram User->>+IoT Hub Portal: Send Command (DeviceId, FrameId) IoT Hub Portal->>+LoRa Key Management Facade: POST /api/cloudtodevicemessage LoRa Key Management Facade->>+Azure IoT Hub: Invoke Device Method to Network Server Azure IoT Hub-->>-LoRa Key Management Facade: Cloud To Device Method Result LoRa Key Management Facade-->>-IoT Hub Portal: Send Cloud To Device Message Result IoT Hub Portal-->>-User: Command send result See https://azure.github.io/iotedge-lorawan-starterkit/2.0.0/quickstart/#cloud-to-device-message for more information about the Cloud To Device Message involed in the LoRa WAN device commands execution flow.","title":"Command execution flow"},{"location":"concepts/#automatic-device-configuration-for-lora-wan","text":"When modifying the device model, the IoT Hub portal will automatically create a new Device Configuration that will target the IoT devices that have the corresponding modelId tag. The IoT Hub portal will create a new Rollout deployment that will remove older configuration and add the new configuration. This process ensure that the devices twin will be updated at scale by the IoT hub and each devices that inherit for the model will be updated according the model configuration. The configuration will be created with the following schema: JSON 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"id\" : \"<model-name>-<timestamp>\" , \"schemaVersion\" : \"1.0\" , \"labels\" : { \"created-by\" : \"Azure IoT hub Portal\" }, \"content\" : { \"deviceContent\" : { \"properties.desired.AppEUI\" : \"<The Device Model OTAA AppEUI>\" , \"properties.desired.SensorDecoder\" : \"<The Device Model Sensor Decoder>\" } }, \"targetCondition\" : \"tags.modelId = '<The model identifier>'\" , \"createdTimeUtc\" : \"2022-02-28T20:29:39.128Z\" , \"lastUpdatedTimeUtc\" : \"2022-02-28T20:29:39.128Z\" , \"priority\" : 0 } Please note that the created-by label is used to identify the configuration created by the IoT Hub portal. For more information see Automatic IoT device and module management .","title":"Automatic device configuration for LoRa WAN"},{"location":"dev-guide/","text":"Developer Guide \u00b6 Directory Structure \u00b6 The code is organized into the following directory structure: src : Source code AzureIoTHub.Portal.Server.Tests : Unit test project for the Portal AzureIoTHub.Portal : The Portal project Client : .NET 6 Blazor Web Assembly project that alow to visualize the IoT Hub data Server : .NET 6 Web API project that provides the API for the Portal Shared : Shared code between the Client and Server projects templates : contains the templates for the \"deploy to Azure\" button Overall Architecture \u00b6 This schema represent the various components and how they interact to have a better understanding of the various solution elements. The user is authenticated by the OpenID Connect server. The user access to the IoT Hub Portal with the OAuth2.0 token. The IoT Hub portal uses the Azure IoT Hub REST API to retrieve the data. The IoT Hub portal uses the Azure Device Provisioning Service to manage IoT Edge devices. The IoT Hub portal uses the Azure Storage account to store the device models configuration (Images, Commands, etc.). The IoT Hub portal uses the LoRa Key Management Facade to send Cloud to Device (C2D) messages to LoRa devices. The LoRa Key Management Facade uses Redis to store its cached data. The LoRa Key Management Facade uses the Azure IoT Hub REST API to retrieve the LoRa device keys and send C2D messages. The IoT Hub portal synchronizes its data with the IoT Hub to provide a consistent view of the data. Note: For more information about the LoRa Key Management Facade, see the Azure IoT Edge LoRaWAN Starter Kit page. Prerequisites \u00b6 The following should be completed before proceeding with the IoT Hub Portal development or deployment in your environment. Before getting started, it is better to master the tools below: Azure platform and Azure IoT Hub. A tutorial can be found here . Blazor WebAssembly and Blazor Server. A traning is available on this site . Docker. An introduction to containerization is available on this page . IoTEdge LoraWAN StarterKit. Have a look at LoRaWAN Starter Kit to get more details on this OSS cross platform private network. Once you know the basics of these technologies and tools, you must follow these last steps to set up your working environment. IoT Hub Portal uses containers to work correctly. Docker is required to launch this project (version >= 4.11.1). Once you have download Docker, you must install the WSL 2 Linux kernel. To do that, please refer to the official Microsoft documentation . You can choose the linux distribution of your choice, for example Ubuntu. Node.js is used to run JavaScript code in the portal. You can download the latest version here .The minimal version required is 16.17.0. You must have an Azure subscription. Get an Azure Free account to start . An Identity provider supporting OpenIDConnect protocol configured with 2 applications (API and web) is required to login to the IoT Hub Portal. See Azure AD B2C Tenant with applications configuration page for example. To develop, you can choose your own IDE or text editor, for example Visual Studio . Secrets \u00b6 Secrets are used to fill in the login credentials to the cloud platform. You have to enter them in a json file to be able to connect to the IoT Hub Portal. Here is a template of a such json file : JSON 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"StorageAccount:ConnectionString\" : \"<CONNECTION_STRING_STORAGE_ACCOUNT>\" , \"StorageAccount:BlobContainerName\" : \"<BLOB_CONTAINER_NAME>\" , \"OIDC:Scope\" : \"<SCOPE>\" , \"OIDC:MetadataUrl\" : \"<METADATA_URL>\" , \"OIDC:ClientId\" : \"<CLIENT_ID>\" , \"OIDC:Authority\" : \"<AUTHORITY>\" , \"OIDC:ApiClientId\" : \"<API_CLIENT_ID>\" , \"LoRaRegionRouterConfig:Url\" : \"<LORA_WAN_ROUTER_CONFIGURATION_URL>\" , \"LoRaKeyManagement:Url\" : \"<LORA_WAN_KEY_MANAGEMENT_URL>\" , \"LoRaKeyManagement:Code\" : \"<LORA_WAN_KEY_MANAGEMENT_CODE>\" , \"LoRaFeature:Enabled\" : \"<TRUE_OR_FALSE>\" , \"Kestrel:Certificates:Development:Password\" : \"<DEV_PASSWORD>\" , \"IoTHub:ConnectionString\" : \"<IOT_HUB_CONNECTION_STRING>\" , \"IoTDPS:ServiceEndpoint\" : \"<SERVICE_END_POINT>\" , \"IoTDPS:LoRaEnrollmentGroup\" : \"<LORA_WAN_ENROLLMENT_GROUP>\" , \"IoTDPS:DefaultEnrollmentGroup\" : \"<LORA_WAN_DEFAULT_ENROLLMENT_GROUP>\" , \"IoTDPS:ConnectionString\" : \"<IOT_DPS_CONNECTION_STRING>\" , \"PostgreSQL:ConnectionString\" : \"<POSTGRE_SQL_CONNECTION_STRING>\" } Note: You must replace all values in the brackets by your own Azure settings. If you can't find them in the Azure Portal, please contact an administrator of this project to have more information. This json file must be added into your project solution. To do that, click on the AzureIoTHub.Server project in Visual Studio and select Manage User Secrets from the context menu. You can now add your secrets inside this file. You are now ready to start your IoT Hub Portal development ! IoT Hub Portal Configuration \u00b6 By deploying the IoT Hub Portal, the user can configure the IoT Hub and the LoRaWAN network. Since the IoT Hub Portal is deployed as a Docker container, the application settings can be configured with environment variables. Application settings \u00b6 Here are different settings that the user can configure: PortalName : The name of the portal (shown in the App Bar and the Page Title). OIDC__Authority : The OpenID Connect issuer. OIDC__MetadataUrl : The OpenID Connect metadata URL (e.g. .well-known/openid-configuration ). OIDC__ClientId : The OpenID Connect client ID for the Web UI. OIDC__ApiClientId : The OpenID Connect client ID for the API. OIDC__Scope : The OpenID Connect scope that represents the portal API. IoTDPS__ServiceEndpoint : The IoT Device Provisioning Service endpoint. IoTDPS__IDScope : The IoT Device Provisioning Service ID scope. LoRaFeature__Enabled : Whether the LoRaWAN feature is enabled or not. LoRaKeyManagement__Url : The LoRa Key Management Facade URL. StorageAccount__BlobContainerName : The name of the Azure Storage container where the device models images are stored. ASPNETCORE_ENVIRONMENT : Built-in environment variable, used to target the configuration provided by a specific environment. Two accepted values: Development : On this environment, logs are produced up to Debug level. Production : Default value if ASPNETCORE_ENVIRONMENT is not set. On this environment, logs are produced up to Information level. Metrics__ExporterRefreshIntervalInSeconds : (Optional, default value 30 ) The refresh interval in seconds to collect custom metrics and expose them to the exporter endpoint. Metrics__LoaderRefreshIntervalInMinutes : (Optional, default value 10 ) The refresh interval in minutes to calculate/refresh custom metrics values. Ideas__Enabled : (Optional, default value false ) To enable Ideas feature when set to true . Ideas__Url : Url of Awesome-Ideas , to publish ideas submitted by users. Ideas__Authentication__Header : (Optional, default value Ocp-Apim-Subscription-Key ) Authentication header name. Ideas__Authentication__Token : Authentication token. Job__SyncDatabaseJobRefreshIntervalInMinutes : (Optional, default value 5 ) The refresh interval in minutes to collect data from Azure IoT Hub (Devices, Iot Edge Devices...) and store them on the database of the Portal. Connection strings \u00b6 Here are different connection strings that the user can configure: IoTHub__ConnectionString : The connection string to the IoT Hub. IoTDPS__ConnectionString : The connection string to the Azure IoT Device Provisioning Service. StorageAccount__ConnectionString : The connection string to the Azure Storage account. LoRaKeyManagement__Code : The LoRa Key Management Facade code. PostgreSQL__ConnectionString : The connection string allowing the connection to the PostgreSQL database. Note: For a production environment, an Azure Key Vault is advised to store the connection strings. Optional Security Settings \u00b6 There are several optional security settings that the user can configure. These settings are not required for the Portal to work. By default the Portal is configured to set security levels to Microsoft.IdentityModel.Tokens defaults but the user can override these settings. UseSecurityHeaders This boolean adds the following headers to all responses : X-Content-Type-Options: nosniff Strict-Transport-Security: max-age=31536000; includeSubDomains - only applied to HTTPS responses X-Frame-Options: Deny - only applied to text/html responses X-XSS-Protection: 1; mode=block - only applied to text/html responses Referrer-Policy: strict-origin-when-cross-origin - only applied to text/html responses Content-Security-Policy: object-src 'none'; form-action 'self'; frame-ancestors 'none' - only applied to text/html responses . The default is true . OIDC__ValidateIssuer Validation of the issuer mitigates forwarding attacks that can occur when an IdentityProvider represents multiple tenants and signs tokens with the same keys. It is possible that a token issued for the same audience could be from a different tenant. For example an application could accept users from contoso.onmicrosoft.com but not fabrikam.onmicrosoft.com, both valid tenants. An application that accepts tokens from fabrikam could forward them to the application that accepts tokens for contoso. This boolean only applies to default issuer validation. If IssuerValidator is set, it will be called regardless of whether this property is true or false. The default is true . OIDC__ValidateAudience Validation of the audience, mitigates forwarding attacks. For example, a site that receives a token, could not replay it to another side. A forwarded token would contain the audience of the original site. This boolean only applies to default audience validation. If AudienceValidator is set, it will be called regardless of whether this property is true or false. The default is true . OIDC__ValidateLifetime This boolean only applies to default lifetime validation. If LifetimeValidator is set, it will be called regardless of whether this property is true or false. The default is true . OIDC__ValidateIssuerSigningKey It is possible for tokens to contain the public key needed to check the signature. For example, X509Data can be hydrated into an X509Certificate, which can be used to validate the signature. In these cases it is important to validate the SigningKey that was used to validate the signature. This boolean only applies to default signing key validation. If IssuerSigningKeyValidator is set, it will be called regardless of whether this property is true or false. The default is false . OIDC_ValidateActor If an actor token is detected, whether it should be validated. The default is false . OIDC_ValidateTokenReplay This boolean only applies to default token replay validation. If TokenReplayValidator is set, it will be called regardless of whether this property is true or false. The default is false . Device tags \u00b6 The IoT Hub portal uses some tags to configure the devices. The tags are stored in the Azure IoT Hub in Device Twins. modelId : The device model ID that is used to retrieve the device model configuration. Storage Account \u00b6 The Storage Account is used to store the device models images. You can use the same Storage Account that is used by the LoRa Key Management Facade. This solution will use tables and blob storage to store its data. There is no need to create the containers, the application will do it for you. Blob Storage \u00b6 The application uses the following blob storage: device-images : The blob storage that contains the device images. Working with the documentation \u00b6 This documentation site is build using Material for MkDocs and Mike . docs/main is a detached branch that is locked and only accepts PRs. On PR merge, Github Pages will automatically update the documentation website. How to update the documentation \u00b6 Checkout the branch that contains the documentation: Bash Session 1 2 git checkout origin/docs/main git checkout -b docs/<your_branch_name> Install dependencies Bash Session 1 pip install -r requirements.txt Previewing as you write Bash Session 1 mkdocs serve PRs are gated by a markdownlint check. You should use markdownlint to lint any new changes on documentation. For example you can use the vs code extension https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint Update the documentation Commit your changes Push your changes to the branch Create a PR Customization \u00b6 Refer to Material for MkDocs documentations: https://squidfunk.github.io/mkdocs-material/customization https://squidfunk.github.io/mkdocs-material/setup Versioning \u00b6 Mike is used to generate automatically a new documentation version when a release has been published, using ci/cd pipelines. For manual workflows (e.g. delete or retitle an existing version), please refer to Mike documentation Problem Details \u00b6 On IoT Hub Portal, we use the library Hellang.Middleware.ProblemDetails which implements RFC7807 to describe issues/problems that occurred on backend. Handle a new exception using Problem Details \u00b6 Create a new exception which extends BaseException . For example see \ud83d\udc49 InternalServerErrorException On Startup class, within the instruction services.AddProblemDetails() : > Your new exception is already catched by the middleware Problem Details because its extends the exception BaseException . > If you want override the behavior of the middleware when processing your exception, you have to add a new mapping within it. \ud83d\udca1 You can also map exceptions from dotnet framework and third parties. Handle Problem Details exceptions on frontend \u00b6 On frontend, http client uses a delegating handler ProblemDetailsHandler to: Execute the http request and wait the response If the response is not successful: The body of the response is deserialized to ProblemDetailsWithExceptionDetails An exception with type ProblemDetailsException (including the error response) is thrown. On Blazor views, http calls must be catched to capture any exceptions of type ProblemDetailsException to be able to execute any business code to process them. When an http call fails, the user must be notified visually by the application: A component Error has been made to respond to this use case. Below an example on how to: Catch an ProblemDetailsException when making a http call Delegate the exception to the Error component, so that it can visually warn the user C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @code { // Inject the reference to the Error component as a cascading parameter [CascadingParameter] public Error Error { get ; set ;} private await Task GetData () { try { // Execute an http request } catch ( ProblemDetailsException exception ) { // Pass the ProblemDetailsException exception to Error component using its method ProcessProblemDetails() // The Error component will alert the user by showing a (snackbar/dialog) using the content of the exception Error ?. ProcessProblemDetails ( exception ) } } }","title":"Developer Guide"},{"location":"dev-guide/#developer-guide","text":"","title":"Developer Guide"},{"location":"dev-guide/#directory-structure","text":"The code is organized into the following directory structure: src : Source code AzureIoTHub.Portal.Server.Tests : Unit test project for the Portal AzureIoTHub.Portal : The Portal project Client : .NET 6 Blazor Web Assembly project that alow to visualize the IoT Hub data Server : .NET 6 Web API project that provides the API for the Portal Shared : Shared code between the Client and Server projects templates : contains the templates for the \"deploy to Azure\" button","title":"Directory Structure"},{"location":"dev-guide/#overall-architecture","text":"This schema represent the various components and how they interact to have a better understanding of the various solution elements. The user is authenticated by the OpenID Connect server. The user access to the IoT Hub Portal with the OAuth2.0 token. The IoT Hub portal uses the Azure IoT Hub REST API to retrieve the data. The IoT Hub portal uses the Azure Device Provisioning Service to manage IoT Edge devices. The IoT Hub portal uses the Azure Storage account to store the device models configuration (Images, Commands, etc.). The IoT Hub portal uses the LoRa Key Management Facade to send Cloud to Device (C2D) messages to LoRa devices. The LoRa Key Management Facade uses Redis to store its cached data. The LoRa Key Management Facade uses the Azure IoT Hub REST API to retrieve the LoRa device keys and send C2D messages. The IoT Hub portal synchronizes its data with the IoT Hub to provide a consistent view of the data. Note: For more information about the LoRa Key Management Facade, see the Azure IoT Edge LoRaWAN Starter Kit page.","title":"Overall Architecture"},{"location":"dev-guide/#prerequisites","text":"The following should be completed before proceeding with the IoT Hub Portal development or deployment in your environment. Before getting started, it is better to master the tools below: Azure platform and Azure IoT Hub. A tutorial can be found here . Blazor WebAssembly and Blazor Server. A traning is available on this site . Docker. An introduction to containerization is available on this page . IoTEdge LoraWAN StarterKit. Have a look at LoRaWAN Starter Kit to get more details on this OSS cross platform private network. Once you know the basics of these technologies and tools, you must follow these last steps to set up your working environment. IoT Hub Portal uses containers to work correctly. Docker is required to launch this project (version >= 4.11.1). Once you have download Docker, you must install the WSL 2 Linux kernel. To do that, please refer to the official Microsoft documentation . You can choose the linux distribution of your choice, for example Ubuntu. Node.js is used to run JavaScript code in the portal. You can download the latest version here .The minimal version required is 16.17.0. You must have an Azure subscription. Get an Azure Free account to start . An Identity provider supporting OpenIDConnect protocol configured with 2 applications (API and web) is required to login to the IoT Hub Portal. See Azure AD B2C Tenant with applications configuration page for example. To develop, you can choose your own IDE or text editor, for example Visual Studio .","title":"Prerequisites"},{"location":"dev-guide/#secrets","text":"Secrets are used to fill in the login credentials to the cloud platform. You have to enter them in a json file to be able to connect to the IoT Hub Portal. Here is a template of a such json file : JSON 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"StorageAccount:ConnectionString\" : \"<CONNECTION_STRING_STORAGE_ACCOUNT>\" , \"StorageAccount:BlobContainerName\" : \"<BLOB_CONTAINER_NAME>\" , \"OIDC:Scope\" : \"<SCOPE>\" , \"OIDC:MetadataUrl\" : \"<METADATA_URL>\" , \"OIDC:ClientId\" : \"<CLIENT_ID>\" , \"OIDC:Authority\" : \"<AUTHORITY>\" , \"OIDC:ApiClientId\" : \"<API_CLIENT_ID>\" , \"LoRaRegionRouterConfig:Url\" : \"<LORA_WAN_ROUTER_CONFIGURATION_URL>\" , \"LoRaKeyManagement:Url\" : \"<LORA_WAN_KEY_MANAGEMENT_URL>\" , \"LoRaKeyManagement:Code\" : \"<LORA_WAN_KEY_MANAGEMENT_CODE>\" , \"LoRaFeature:Enabled\" : \"<TRUE_OR_FALSE>\" , \"Kestrel:Certificates:Development:Password\" : \"<DEV_PASSWORD>\" , \"IoTHub:ConnectionString\" : \"<IOT_HUB_CONNECTION_STRING>\" , \"IoTDPS:ServiceEndpoint\" : \"<SERVICE_END_POINT>\" , \"IoTDPS:LoRaEnrollmentGroup\" : \"<LORA_WAN_ENROLLMENT_GROUP>\" , \"IoTDPS:DefaultEnrollmentGroup\" : \"<LORA_WAN_DEFAULT_ENROLLMENT_GROUP>\" , \"IoTDPS:ConnectionString\" : \"<IOT_DPS_CONNECTION_STRING>\" , \"PostgreSQL:ConnectionString\" : \"<POSTGRE_SQL_CONNECTION_STRING>\" } Note: You must replace all values in the brackets by your own Azure settings. If you can't find them in the Azure Portal, please contact an administrator of this project to have more information. This json file must be added into your project solution. To do that, click on the AzureIoTHub.Server project in Visual Studio and select Manage User Secrets from the context menu. You can now add your secrets inside this file. You are now ready to start your IoT Hub Portal development !","title":"Secrets"},{"location":"dev-guide/#iot-hub-portal-configuration","text":"By deploying the IoT Hub Portal, the user can configure the IoT Hub and the LoRaWAN network. Since the IoT Hub Portal is deployed as a Docker container, the application settings can be configured with environment variables.","title":"IoT Hub Portal Configuration"},{"location":"dev-guide/#application-settings","text":"Here are different settings that the user can configure: PortalName : The name of the portal (shown in the App Bar and the Page Title). OIDC__Authority : The OpenID Connect issuer. OIDC__MetadataUrl : The OpenID Connect metadata URL (e.g. .well-known/openid-configuration ). OIDC__ClientId : The OpenID Connect client ID for the Web UI. OIDC__ApiClientId : The OpenID Connect client ID for the API. OIDC__Scope : The OpenID Connect scope that represents the portal API. IoTDPS__ServiceEndpoint : The IoT Device Provisioning Service endpoint. IoTDPS__IDScope : The IoT Device Provisioning Service ID scope. LoRaFeature__Enabled : Whether the LoRaWAN feature is enabled or not. LoRaKeyManagement__Url : The LoRa Key Management Facade URL. StorageAccount__BlobContainerName : The name of the Azure Storage container where the device models images are stored. ASPNETCORE_ENVIRONMENT : Built-in environment variable, used to target the configuration provided by a specific environment. Two accepted values: Development : On this environment, logs are produced up to Debug level. Production : Default value if ASPNETCORE_ENVIRONMENT is not set. On this environment, logs are produced up to Information level. Metrics__ExporterRefreshIntervalInSeconds : (Optional, default value 30 ) The refresh interval in seconds to collect custom metrics and expose them to the exporter endpoint. Metrics__LoaderRefreshIntervalInMinutes : (Optional, default value 10 ) The refresh interval in minutes to calculate/refresh custom metrics values. Ideas__Enabled : (Optional, default value false ) To enable Ideas feature when set to true . Ideas__Url : Url of Awesome-Ideas , to publish ideas submitted by users. Ideas__Authentication__Header : (Optional, default value Ocp-Apim-Subscription-Key ) Authentication header name. Ideas__Authentication__Token : Authentication token. Job__SyncDatabaseJobRefreshIntervalInMinutes : (Optional, default value 5 ) The refresh interval in minutes to collect data from Azure IoT Hub (Devices, Iot Edge Devices...) and store them on the database of the Portal.","title":"Application settings"},{"location":"dev-guide/#connection-strings","text":"Here are different connection strings that the user can configure: IoTHub__ConnectionString : The connection string to the IoT Hub. IoTDPS__ConnectionString : The connection string to the Azure IoT Device Provisioning Service. StorageAccount__ConnectionString : The connection string to the Azure Storage account. LoRaKeyManagement__Code : The LoRa Key Management Facade code. PostgreSQL__ConnectionString : The connection string allowing the connection to the PostgreSQL database. Note: For a production environment, an Azure Key Vault is advised to store the connection strings.","title":"Connection strings"},{"location":"dev-guide/#optional-security-settings","text":"There are several optional security settings that the user can configure. These settings are not required for the Portal to work. By default the Portal is configured to set security levels to Microsoft.IdentityModel.Tokens defaults but the user can override these settings. UseSecurityHeaders This boolean adds the following headers to all responses : X-Content-Type-Options: nosniff Strict-Transport-Security: max-age=31536000; includeSubDomains - only applied to HTTPS responses X-Frame-Options: Deny - only applied to text/html responses X-XSS-Protection: 1; mode=block - only applied to text/html responses Referrer-Policy: strict-origin-when-cross-origin - only applied to text/html responses Content-Security-Policy: object-src 'none'; form-action 'self'; frame-ancestors 'none' - only applied to text/html responses . The default is true . OIDC__ValidateIssuer Validation of the issuer mitigates forwarding attacks that can occur when an IdentityProvider represents multiple tenants and signs tokens with the same keys. It is possible that a token issued for the same audience could be from a different tenant. For example an application could accept users from contoso.onmicrosoft.com but not fabrikam.onmicrosoft.com, both valid tenants. An application that accepts tokens from fabrikam could forward them to the application that accepts tokens for contoso. This boolean only applies to default issuer validation. If IssuerValidator is set, it will be called regardless of whether this property is true or false. The default is true . OIDC__ValidateAudience Validation of the audience, mitigates forwarding attacks. For example, a site that receives a token, could not replay it to another side. A forwarded token would contain the audience of the original site. This boolean only applies to default audience validation. If AudienceValidator is set, it will be called regardless of whether this property is true or false. The default is true . OIDC__ValidateLifetime This boolean only applies to default lifetime validation. If LifetimeValidator is set, it will be called regardless of whether this property is true or false. The default is true . OIDC__ValidateIssuerSigningKey It is possible for tokens to contain the public key needed to check the signature. For example, X509Data can be hydrated into an X509Certificate, which can be used to validate the signature. In these cases it is important to validate the SigningKey that was used to validate the signature. This boolean only applies to default signing key validation. If IssuerSigningKeyValidator is set, it will be called regardless of whether this property is true or false. The default is false . OIDC_ValidateActor If an actor token is detected, whether it should be validated. The default is false . OIDC_ValidateTokenReplay This boolean only applies to default token replay validation. If TokenReplayValidator is set, it will be called regardless of whether this property is true or false. The default is false .","title":"Optional Security Settings"},{"location":"dev-guide/#device-tags","text":"The IoT Hub portal uses some tags to configure the devices. The tags are stored in the Azure IoT Hub in Device Twins. modelId : The device model ID that is used to retrieve the device model configuration.","title":"Device tags"},{"location":"dev-guide/#storage-account","text":"The Storage Account is used to store the device models images. You can use the same Storage Account that is used by the LoRa Key Management Facade. This solution will use tables and blob storage to store its data. There is no need to create the containers, the application will do it for you.","title":"Storage Account"},{"location":"dev-guide/#blob-storage","text":"The application uses the following blob storage: device-images : The blob storage that contains the device images.","title":"Blob Storage"},{"location":"dev-guide/#working-with-the-documentation","text":"This documentation site is build using Material for MkDocs and Mike . docs/main is a detached branch that is locked and only accepts PRs. On PR merge, Github Pages will automatically update the documentation website.","title":"Working with the documentation"},{"location":"dev-guide/#how-to-update-the-documentation","text":"Checkout the branch that contains the documentation: Bash Session 1 2 git checkout origin/docs/main git checkout -b docs/<your_branch_name> Install dependencies Bash Session 1 pip install -r requirements.txt Previewing as you write Bash Session 1 mkdocs serve PRs are gated by a markdownlint check. You should use markdownlint to lint any new changes on documentation. For example you can use the vs code extension https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint Update the documentation Commit your changes Push your changes to the branch Create a PR","title":"How to update the documentation"},{"location":"dev-guide/#customization","text":"Refer to Material for MkDocs documentations: https://squidfunk.github.io/mkdocs-material/customization https://squidfunk.github.io/mkdocs-material/setup","title":"Customization"},{"location":"dev-guide/#versioning","text":"Mike is used to generate automatically a new documentation version when a release has been published, using ci/cd pipelines. For manual workflows (e.g. delete or retitle an existing version), please refer to Mike documentation","title":"Versioning"},{"location":"dev-guide/#problem-details","text":"On IoT Hub Portal, we use the library Hellang.Middleware.ProblemDetails which implements RFC7807 to describe issues/problems that occurred on backend.","title":"Problem Details"},{"location":"dev-guide/#handle-a-new-exception-using-problem-details","text":"Create a new exception which extends BaseException . For example see \ud83d\udc49 InternalServerErrorException On Startup class, within the instruction services.AddProblemDetails() : > Your new exception is already catched by the middleware Problem Details because its extends the exception BaseException . > If you want override the behavior of the middleware when processing your exception, you have to add a new mapping within it. \ud83d\udca1 You can also map exceptions from dotnet framework and third parties.","title":"Handle a new exception using Problem Details"},{"location":"dev-guide/#handle-problem-details-exceptions-on-frontend","text":"On frontend, http client uses a delegating handler ProblemDetailsHandler to: Execute the http request and wait the response If the response is not successful: The body of the response is deserialized to ProblemDetailsWithExceptionDetails An exception with type ProblemDetailsException (including the error response) is thrown. On Blazor views, http calls must be catched to capture any exceptions of type ProblemDetailsException to be able to execute any business code to process them. When an http call fails, the user must be notified visually by the application: A component Error has been made to respond to this use case. Below an example on how to: Catch an ProblemDetailsException when making a http call Delegate the exception to the Error component, so that it can visually warn the user C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @code { // Inject the reference to the Error component as a cascading parameter [CascadingParameter] public Error Error { get ; set ;} private await Task GetData () { try { // Execute an http request } catch ( ProblemDetailsException exception ) { // Pass the ProblemDetailsException exception to Error component using its method ProcessProblemDetails() // The Error component will alert the user by showing a (snackbar/dialog) using the content of the exception Error ?. ProcessProblemDetails ( exception ) } } }","title":"Handle Problem Details exceptions on frontend"},{"location":"open-api/","text":"Web API Reference \u00b6","title":"Web API Reference"},{"location":"open-api/#web-api-reference","text":"","title":"Web API Reference"},{"location":"about/credits/","text":"Credits \u00b6 Azure IoT Edge LoRaWAN Starter Kit","title":"Credits"},{"location":"about/credits/#credits","text":"Azure IoT Edge LoRaWAN Starter Kit","title":"Credits"},{"location":"about/issues/","text":"Known Issues and Limitations \u00b6 Refer to Known Issues for known issues, gotchas and limitations.","title":"Known Issues"},{"location":"about/issues/#known-issues-and-limitations","text":"Refer to Known Issues for known issues, gotchas and limitations.","title":"Known Issues and Limitations"},{"location":"about/license/","text":"MIT License \u00b6 Copyright \u00a9 2021 CGI France Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#mit-license","text":"Copyright \u00a9 2021 CGI France Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"about/support/","text":"Support \u00b6 This is an open source solution. For bugs and issues with the codebase please log an issue in this repo.","title":"Support"},{"location":"about/support/#support","text":"This is an open source solution. For bugs and issues with the codebase please log an issue in this repo.","title":"Support"},{"location":"dev-guide/testing/unit-tests-common-practices/","text":"Unit Tests Common Practices \u00b6 Naming Conventions \u00b6 Test class \u00b6 The test class should follow the naming convention [ClassUnderTest]Tests . Example: The test class for a class named ProductController should be named ProductControllerTests : C# 1 2 3 4 5 [TestFixture] public class ProductControllerTests { ... } Test method \u00b6 The test method should follow the naming convention [MethodUnderTest]_[BehaviourToTest]_[ExpectedResult] . Example: A method named GetProduct should be tested to see if it returns an existing product. The name of the test should be GetProduct_ProductExist_ProductReturned : C# 1 2 3 4 5 [Test] public async Task GetProduct_ProductExist_ProductReturned () { ... } Unit Test Skeleton: Three Steps/Parts \u00b6 A unit test should be devided into three steps: Arrange: The first part where the input/expected data are defined Act: The second part where the behavior under test is executed Assert: The third and final part where assertions are made These three parts are visually defined with comments so that unit tests are humanly comprehensible: C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [Test] public async Task GetProduct_ProductExist_ProductReturned () { // Arrange var productId = Guid . NewGuid (). ToString (); var expectedProduct = new Product { Id = productId }; // Act var product = this . productService . GetProduct ( productId ); // Asset _ = product . Should (). BeEquivalentTo ( expectedProduct ); } Tip On the IoT Hub portal, we use the fluentassertions library for unit tests for natural/human reusable assertions. Mock \u00b6 A unit test should only test its assigned layer. Any lower layer that requires/interacts with external resources should be mocked to ensure sure that the unit tests are idempotent. Note Example: We want to implement unit tests for a controller that requires three services. Each service depends on other services/repositories/http clients that need external resources like databases, APIs... Any execution of unit tests that depend on these external resources can be altered (not idempotent) because they depend on the uptime and data of these resources. On the IoT Hub portal, we use the library Moq for mocking within unit tests: C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 [TestFixture] public class ProductControllerTests { private MockRepository mockRepository ; private Mock < IProductRepository > mockProductRepository ; private IProductService productService ; [SetUp] public void SetUp () { // Init MockRepository with strict behaviour this . mockRepository = new MockRepository ( MockBehavior . Strict ); // Init the mock of IProductRepository this . mockProductRepository = this . mockRepository . Create < IProductRepository >(); // Init the service ProductService. The object mock ProductRepository is passed the contructor of ProductService this . productService = new ProductService ( this . mockProductRepository . Object ); } [Test] public async Task GetProduct_ProductExist_ProductReturned () { // Arrange var productId = Guid . NewGuid (). ToString (); var expectedProduct = new Product { Id = productId }; // Setup mock of GetByIdAsync of the repository ProductRepository to return the expected product when given the correct product id _ = this . mockProductRepository . Setup ( repository => repository . GetByIdAsync ( productId )) . ReturnsAsync ( expectedProduct ); // Act var product = this . productService . GetProduct ( productId ); // Asset _ = product . Should (). BeEquivalentTo ( expectedProduct ); // Assert that all mocks setups have been called _ = MockRepository . VerifyAll (); } }","title":"Unit Tests Common Practices"},{"location":"dev-guide/testing/unit-tests-common-practices/#unit-tests-common-practices","text":"","title":"Unit Tests Common Practices"},{"location":"dev-guide/testing/unit-tests-common-practices/#naming-conventions","text":"","title":"Naming Conventions"},{"location":"dev-guide/testing/unit-tests-common-practices/#test-class","text":"The test class should follow the naming convention [ClassUnderTest]Tests . Example: The test class for a class named ProductController should be named ProductControllerTests : C# 1 2 3 4 5 [TestFixture] public class ProductControllerTests { ... }","title":"Test class"},{"location":"dev-guide/testing/unit-tests-common-practices/#test-method","text":"The test method should follow the naming convention [MethodUnderTest]_[BehaviourToTest]_[ExpectedResult] . Example: A method named GetProduct should be tested to see if it returns an existing product. The name of the test should be GetProduct_ProductExist_ProductReturned : C# 1 2 3 4 5 [Test] public async Task GetProduct_ProductExist_ProductReturned () { ... }","title":"Test method"},{"location":"dev-guide/testing/unit-tests-common-practices/#unit-test-skeleton-three-stepsparts","text":"A unit test should be devided into three steps: Arrange: The first part where the input/expected data are defined Act: The second part where the behavior under test is executed Assert: The third and final part where assertions are made These three parts are visually defined with comments so that unit tests are humanly comprehensible: C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [Test] public async Task GetProduct_ProductExist_ProductReturned () { // Arrange var productId = Guid . NewGuid (). ToString (); var expectedProduct = new Product { Id = productId }; // Act var product = this . productService . GetProduct ( productId ); // Asset _ = product . Should (). BeEquivalentTo ( expectedProduct ); } Tip On the IoT Hub portal, we use the fluentassertions library for unit tests for natural/human reusable assertions.","title":"Unit Test Skeleton: Three Steps/Parts"},{"location":"dev-guide/testing/unit-tests-common-practices/#mock","text":"A unit test should only test its assigned layer. Any lower layer that requires/interacts with external resources should be mocked to ensure sure that the unit tests are idempotent. Note Example: We want to implement unit tests for a controller that requires three services. Each service depends on other services/repositories/http clients that need external resources like databases, APIs... Any execution of unit tests that depend on these external resources can be altered (not idempotent) because they depend on the uptime and data of these resources. On the IoT Hub portal, we use the library Moq for mocking within unit tests: C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 [TestFixture] public class ProductControllerTests { private MockRepository mockRepository ; private Mock < IProductRepository > mockProductRepository ; private IProductService productService ; [SetUp] public void SetUp () { // Init MockRepository with strict behaviour this . mockRepository = new MockRepository ( MockBehavior . Strict ); // Init the mock of IProductRepository this . mockProductRepository = this . mockRepository . Create < IProductRepository >(); // Init the service ProductService. The object mock ProductRepository is passed the contructor of ProductService this . productService = new ProductService ( this . mockProductRepository . Object ); } [Test] public async Task GetProduct_ProductExist_ProductReturned () { // Arrange var productId = Guid . NewGuid (). ToString (); var expectedProduct = new Product { Id = productId }; // Setup mock of GetByIdAsync of the repository ProductRepository to return the expected product when given the correct product id _ = this . mockProductRepository . Setup ( repository => repository . GetByIdAsync ( productId )) . ReturnsAsync ( expectedProduct ); // Act var product = this . productService . GetProduct ( productId ); // Asset _ = product . Should (). BeEquivalentTo ( expectedProduct ); // Assert that all mocks setups have been called _ = MockRepository . VerifyAll (); } }","title":"Mock"},{"location":"dev-guide/testing/unit-tests-on-blazor-components/","text":"Unit Tests on Blazor components \u00b6 Info To test Blazor components on the Iot Hob Portal, we use the library bUnit How to unit test component \u00b6 Let us assume we have a compoment ProductDetail to test. Example of the content of the component ProductDetail 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @inject IProductService ProductService @if ( product != null ) { < p id = \"product-id\" > @product . Id </ p > } @code { [Parameter] public string ProductId { get ; set ; } private Product product ; protected override async Task OnInitializedAsync () { await GetProduct (); } private async Task GetProduct () { try { product = await ProductService . GetProduct ( ProductId ); } catch ( ProblemDetailsException exception ) { Error ?. ProcessProblemDetails ( exception ); } } } First you have to a unit test class that extend 1 2 3 4 [TestFixture] public class ProductDetailTests : BlazorUnitTest { } Info The class BlazorUnitTest provides helpers/test context dedicated for unit tests for the blazor component. It also avoids code duplication of unit test classes. Override the method Setup 1 2 3 4 5 6 7 8 9 [TestFixture] public class ProductDetailTests : BlazorUnitTest { public override void Setup () { // Don't forget the method base.Setup() to initialize existing helpers base . Setup (); } } Setup the mockup of the service IProductService 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [TestFixture] public class ProductDetailTests : BlazorUnitTest { // Declare the mock of IProductService private Mock < IProductService > productServiceMock ; public override void Setup () { base . Setup (); // Intialize the mock of IProductService this . productServiceMock = MockRepository . Create < IProductService >(); // Add the mock of IProductService as a singleton for resolution _ = Services . AddSingleton ( this . productServiceMock . Object ); } } Info After configuring the test class setup, you can start implementing unit tests. Below is an example of a a unit test that checks whether the GetProduct method of the serivce ProductService service was called after the component was initialized: C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 [TestFixture] public class ProductDetailTests : BlazorUnitTest { ... [Test] public void OnInitializedAsync_GetProduct_ProductIsRetrieved () { // Arrange var expectedProduct = Fixture . Create < Product >(); // Setup mock of GetProduct of the service ProductService _ = this . productServiceMock . Setup ( service => service . GetProduct ( expectedProduct . Id )) . ReturnsAsync ( expectedProduct ); // Act // Render the component ProductDetail with the required ProductId parameter var cut = RenderComponent < ProductDetail >( ComponentParameter . CreateParameter ( \"ProductId\" , expectedProduct . Id )); // You can wait for a specific element to be rendered before assertions using a css selector, for example the DOM element with id product-id _ = cut . WaitForElement ( \"#product-id\" ); // Assert // Assert that all mocks setups have been called cut . WaitForAssertion (() => MockRepository . VerifyAll ()); } } Tip WaitForAssertion is useful in asserting asynchronous changes: It will blocks and waits in a test method until the specified assertion action does not throw an exception, or until the timeout is reached (the default timeout is one second). Assertion of asynchronous changes Tip Within unit tests on Blazor components, you can interact with HTML DOM and query rendered HTMLelements (buttons, div...) by using CSS selectors (id, class...) Lean more about CSS selectors How to unit test a component requiring an external component \u00b6 Some components proposed by MudBlazor (MudAutocomplete, MudSelect...) use another component MudPopoverProvider to display elements. If in a unit test that uses these MudBlazor components, the MudPopoverProvider component is not rendered, the interactions with these components are restricted. Let us start with the following example: Example of the content of the component SearchState 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 < MudAutocomplete T = \"string\" Label = \"US States\" @bind - Value = \"selectedState\" SearchFunc = \"@Search\" /> @code { private string selectedState ; private string [] states = { \"Alabama\" , \"Colorado\" , \"Missouri\" , \"Wisconsin\" } private async Task < IEnumerable < string >> Search ( string value ) { // In real life use an asynchronous function for fetching data from an api. await Task . Delay ( 5 ); // if text is null or empty, show complete list if ( string . IsNullOrEmpty ( value )) return states ; return states . Where ( x => x . Contains ( value , StringComparison . InvariantCultureIgnoreCase )); } } We want to test the search when a user interacts with the MudAutocomplete component to search for the state Wisconsin : C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 [TestFixture] public class SearchStateTests : BlazorUnitTest { ... [Test] public void Search_UserSearchAndSelectState_StateIsSelected () { // Arrange var userQuery = \"Wis\" ; // First render MudPopoverProvider component var popoverProvider = RenderComponent < MudPopoverProvider >(); // Second, rendrer the component SearchState (under unit test) var cut = RenderComponent < SearchState >(); // Find the MudAutocomplete component within SearchState component var autocompleteComponent = cut . FindComponent < MudAutocomplete < string >>(); // Fire click event on, autocompleteComponent . Find ( \"input\" ). Click (); autocompleteComponent . Find ( \"input\" ). Input ( userQuery ); // Wait until the count of element in the list rendred on the component MudPopoverProvider is equals to one popoverProvider . WaitForAssertion (() => popoverProvider . FindAll ( \"div.mud-list-item\" ). Count . Should (). Be ( 1 )); // Act // Get the only element present on the list var stateElement = popoverProvider . Find ( \"div.mud-list-item\" ); // Fire click event on the element stateElement . Click (); // Assert // Check if the MudAutocomplete compoment has been closed after the click event cut . WaitForAssertion (() => autocompleteComponent . Instance . IsOpen . Should (). BeFalse ()); ... } }","title":"Unit Tests on Blazor components"},{"location":"dev-guide/testing/unit-tests-on-blazor-components/#unit-tests-on-blazor-components","text":"Info To test Blazor components on the Iot Hob Portal, we use the library bUnit","title":"Unit Tests on Blazor components"},{"location":"dev-guide/testing/unit-tests-on-blazor-components/#how-to-unit-test-component","text":"Let us assume we have a compoment ProductDetail to test. Example of the content of the component ProductDetail 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @inject IProductService ProductService @if ( product != null ) { < p id = \"product-id\" > @product . Id </ p > } @code { [Parameter] public string ProductId { get ; set ; } private Product product ; protected override async Task OnInitializedAsync () { await GetProduct (); } private async Task GetProduct () { try { product = await ProductService . GetProduct ( ProductId ); } catch ( ProblemDetailsException exception ) { Error ?. ProcessProblemDetails ( exception ); } } } First you have to a unit test class that extend 1 2 3 4 [TestFixture] public class ProductDetailTests : BlazorUnitTest { } Info The class BlazorUnitTest provides helpers/test context dedicated for unit tests for the blazor component. It also avoids code duplication of unit test classes. Override the method Setup 1 2 3 4 5 6 7 8 9 [TestFixture] public class ProductDetailTests : BlazorUnitTest { public override void Setup () { // Don't forget the method base.Setup() to initialize existing helpers base . Setup (); } } Setup the mockup of the service IProductService 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [TestFixture] public class ProductDetailTests : BlazorUnitTest { // Declare the mock of IProductService private Mock < IProductService > productServiceMock ; public override void Setup () { base . Setup (); // Intialize the mock of IProductService this . productServiceMock = MockRepository . Create < IProductService >(); // Add the mock of IProductService as a singleton for resolution _ = Services . AddSingleton ( this . productServiceMock . Object ); } } Info After configuring the test class setup, you can start implementing unit tests. Below is an example of a a unit test that checks whether the GetProduct method of the serivce ProductService service was called after the component was initialized: C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 [TestFixture] public class ProductDetailTests : BlazorUnitTest { ... [Test] public void OnInitializedAsync_GetProduct_ProductIsRetrieved () { // Arrange var expectedProduct = Fixture . Create < Product >(); // Setup mock of GetProduct of the service ProductService _ = this . productServiceMock . Setup ( service => service . GetProduct ( expectedProduct . Id )) . ReturnsAsync ( expectedProduct ); // Act // Render the component ProductDetail with the required ProductId parameter var cut = RenderComponent < ProductDetail >( ComponentParameter . CreateParameter ( \"ProductId\" , expectedProduct . Id )); // You can wait for a specific element to be rendered before assertions using a css selector, for example the DOM element with id product-id _ = cut . WaitForElement ( \"#product-id\" ); // Assert // Assert that all mocks setups have been called cut . WaitForAssertion (() => MockRepository . VerifyAll ()); } } Tip WaitForAssertion is useful in asserting asynchronous changes: It will blocks and waits in a test method until the specified assertion action does not throw an exception, or until the timeout is reached (the default timeout is one second). Assertion of asynchronous changes Tip Within unit tests on Blazor components, you can interact with HTML DOM and query rendered HTMLelements (buttons, div...) by using CSS selectors (id, class...) Lean more about CSS selectors","title":"How to unit test component"},{"location":"dev-guide/testing/unit-tests-on-blazor-components/#how-to-unit-test-a-component-requiring-an-external-component","text":"Some components proposed by MudBlazor (MudAutocomplete, MudSelect...) use another component MudPopoverProvider to display elements. If in a unit test that uses these MudBlazor components, the MudPopoverProvider component is not rendered, the interactions with these components are restricted. Let us start with the following example: Example of the content of the component SearchState 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 < MudAutocomplete T = \"string\" Label = \"US States\" @bind - Value = \"selectedState\" SearchFunc = \"@Search\" /> @code { private string selectedState ; private string [] states = { \"Alabama\" , \"Colorado\" , \"Missouri\" , \"Wisconsin\" } private async Task < IEnumerable < string >> Search ( string value ) { // In real life use an asynchronous function for fetching data from an api. await Task . Delay ( 5 ); // if text is null or empty, show complete list if ( string . IsNullOrEmpty ( value )) return states ; return states . Where ( x => x . Contains ( value , StringComparison . InvariantCultureIgnoreCase )); } } We want to test the search when a user interacts with the MudAutocomplete component to search for the state Wisconsin : C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 [TestFixture] public class SearchStateTests : BlazorUnitTest { ... [Test] public void Search_UserSearchAndSelectState_StateIsSelected () { // Arrange var userQuery = \"Wis\" ; // First render MudPopoverProvider component var popoverProvider = RenderComponent < MudPopoverProvider >(); // Second, rendrer the component SearchState (under unit test) var cut = RenderComponent < SearchState >(); // Find the MudAutocomplete component within SearchState component var autocompleteComponent = cut . FindComponent < MudAutocomplete < string >>(); // Fire click event on, autocompleteComponent . Find ( \"input\" ). Click (); autocompleteComponent . Find ( \"input\" ). Input ( userQuery ); // Wait until the count of element in the list rendred on the component MudPopoverProvider is equals to one popoverProvider . WaitForAssertion (() => popoverProvider . FindAll ( \"div.mud-list-item\" ). Count . Should (). Be ( 1 )); // Act // Get the only element present on the list var stateElement = popoverProvider . Find ( \"div.mud-list-item\" ); // Fire click event on the element stateElement . Click (); // Assert // Check if the MudAutocomplete compoment has been closed after the click event cut . WaitForAssertion (() => autocompleteComponent . Instance . IsOpen . Should (). BeFalse ()); ... } }","title":"How to unit test a component requiring an external component"}]}