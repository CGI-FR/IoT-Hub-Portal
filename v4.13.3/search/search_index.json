{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IoT Hub Portal","text":"<p>This project aims to provide a solution for handling IoT Devices easyly. It leverages on Azure IoT Hub or AWS IoT Core for connectivity and device management.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Portal Authentication</li> <li>IoT Device &amp; device Model management</li> <li>IoT Edge device management</li> <li>C2D Methods</li> <li>LoRA WAN device connectivity</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#azure","title":"Azure","text":"<p>Quick Start for Azure environment.</p>"},{"location":"#amazon-web-services","title":"Amazon Web Services","text":"<p>Quick Start for AWS environment.</p>"},{"location":"#known-issues-and-limitations","title":"Known Issues and Limitations","text":"<p>Refer to Known Issues for known issues, gotchas and limitations.</p>"},{"location":"#support","title":"Support","text":"<p>This is an open source solution. For bugs and issues with the codebase please log an issue in this repo.</p>"},{"location":"#credits","title":"Credits","text":"<ul> <li>Azure IoT Edge LoRaWAN Starter Kit</li> </ul>"},{"location":"aws/","title":"AWS configurations","text":""},{"location":"aws/#overall-architecture","title":"Overall Architecture","text":"<p>This schema represent the various components and how they interact to have a better understanding of the various solution elements.</p> <p></p> <ol> <li>The user is authenticated by the OpenID Connect server.</li> <li>The user access to the IoT Hub Portal with the OAuth2.0 token.</li> <li>The IoT Hub portal uses the AWS IoT REST API to retrieve the data.</li> <li>The IoT Hub portal uses the AWS S3 storage to store the device models configuration (Images, Commands, etc.).</li> <li>The IoT Hub portal synchronizes its data with the IoT Hub to provide a consistent view of the data.</li> </ol>"},{"location":"aws/#quick-start","title":"Quick Start","text":""},{"location":"aws/#prerequisites","title":"Prerequisites","text":"<ul> <li>You must have an AWS Account. Get an AWS Free account to get started.</li> <li> <p>You must enable Fleet Indexing for registry and shadow Using AWS CLI:</p> Bash Session<pre><code>aws iot update-indexing-configuration --thing-indexing-configuration thingIndexingMode=REGISTRY_AND_SHADOW\n</code></pre> <p>Please note that you'll need the necessary permissions to execute this command. Make sure your AWS IAM user or role has the appropriate permissions to access and modify the IoT indexing configuration.</p> </li> </ul>"},{"location":"aws/#deployed-resources","title":"Deployed Resources","text":"<p>The template will deploy in your AWS Account the Following resources:  </p> <ul> <li>AWS RDS - Database for PostgreSQL</li> <li>AWS S3 Bucket</li> <li>AWS App Runner Service</li> </ul>"},{"location":"aws/#instructions","title":"Instructions","text":"<ol> <li> <p>Choose a stack name for your AWS Deployment.</p> </li> <li> <p>Follow next step below to start your deployment:</p> <ol> <li> <p>Press on the button here below to download the template AWS: Download the template</p> </li> <li> <p>Import your template : From the AWS console: CloudFormation new stack         - You can change the deployment region by changing the region directly in the URL         - In \"Upload a template file\" import the previously downloaded file With AWS CLI:</p> Bash Session<pre><code>aws cloudformation deploy --template /path_to_template/awsdeploy.yml --stack-name your-stack-name --region your-region\n</code></pre> <p>see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-cli-deploy.html for more option about aws cloudformation deploy</p> </li> </ol> </li> <li> <p>You will get to a page asking you to fill the following fields:</p> <ul> <li>Stack Name: A name for the stack where all the template resource would be put into, just choose a meaningful name.</li> <li>PostgreSQL user: The PostgreSQL user name to be used for the IoT Hub Portal database.</li> <li>PostgreSQL password: The PostgreSQL password to be used for the IoT Hub Portal database.</li> <li>AWS Access Key: The AWS Access Key of your AWS environment.</li> <li>AWS Access Secret Key: The AWS Access Secret Key of your AWS environment.</li> <li>Api Client Id: the ID of the API client that will be used to authenticate the portal.</li> <li>Client Id: the ID of the web client that will be used to authenticate the portal.</li> <li>Open Id Authority: The OpenID authority used by the portal.</li> <li>OpenId Metadata URL: The OpenID metadata URL used by the portal.</li> <li>OpenId Scope Name: The Open ID Scope name</li> </ul> </li> </ol>"},{"location":"aws/#configurations","title":"Configurations","text":"<p>This configurations are used to get access to AWS cloud Platform. You have to enter them in a <code>json</code> file to be able to connect to the Iot Hub Portal. Here is a template of a such <code>json</code> file.</p> JSON<pre><code>{\n  \"CloudProvider\": \"AWS\",\n  \"AWS:Access\": \"&lt;ACCESS_KEY&gt;\",\n  \"AWS:AccessSecret\": \"&lt;ACCESS_SECRET_KEY&gt;\",\n  \"AWS:Region\": \"&lt;REGION_KEY&gt;\",\n  \"AWS:BucketName\": \"&lt;BUCKET_NAME&gt;\",  \n  \"AWS:AccountId\": \"&lt;ACCOUNT_IDENTIFIER&gt;\",\n  \"AWS:GreengrassRequiredRoles:&lt;ID&gt;\": \"&lt;GREENGRASS_ROLE_NAME&gt;\",\n  \"OIDC:Scope\": \"&lt;SCOPE&gt;\",\n  \"OIDC:MetadataUrl\": \"&lt;METADATA_URL&gt;\",\n  \"OIDC:ClientId\": \"&lt;CLIENT_ID&gt;\",\n  \"OIDC:Authority\": \"&lt;AUTHORITY&gt;\",\n  \"OIDC:ApiClientId\": \"&lt;API_CLIENT_ID&gt;\",\n  \"PostgreSQL:ConnectionString\": \"&lt;POSTGRE_SQL_CONNECTION_STRING&gt;\"\n}\n</code></pre> <p>Note: You must replace all values in the brackets by your own AWS settings. If you can't find them in the AWS Portal, please contact an administrator of this project to have more information.</p> <p>You are now ready to start your IoT Hub Portal development !</p>"},{"location":"azure/","title":"Azure Configurations","text":""},{"location":"azure/#overall-architecture","title":"Overall Architecture","text":"<p>This schema represent the various components and how they interact to have a better understanding of the various solution elements.</p> <p></p> <ol> <li>The user is authenticated by the OpenID Connect server.</li> <li>The user access to the IoT Hub Portal with the OAuth2.0 token.</li> <li>The IoT Hub portal uses the Azure IoT Hub REST API to retrieve the data.</li> <li>The IoT Hub portal uses the Azure Device Provisioning Service to manage IoT Edge devices.</li> <li>The IoT Hub portal uses the Azure Storage account to store the device models configuration (Images, Commands, etc.).</li> <li>The IoT Hub portal uses the LoRa Key Management Facade to send Cloud to Device (C2D) messages to LoRa devices.</li> <li>The LoRa Key Management Facade uses Redis to store its cached data.</li> <li>The LoRa Key Management Facade uses the Azure IoT Hub REST API to retrieve the LoRa device keys and send C2D messages.</li> <li>The IoT Hub portal synchronizes its data with the IoT Hub to provide a consistent view of the data.</li> </ol> <p>Note: For more information about the LoRa Key Management Facade, see the Azure IoT Edge LoRaWAN Starter Kit page.</p>"},{"location":"azure/#quick-start","title":"Quick Start","text":""},{"location":"azure/#prerequisites","title":"Prerequisites","text":"<ul> <li>You must have an Azure subscription. Get an Azure Free account to get started.</li> <li>You must have configured an Azure AD B2C Tenant with applications. See Portal AD applications configuration page.</li> <li>Understand how IoT Edge LoraWAN StarterKit work. Have a look at https://azure.github.io/iotedge-lorawan-starterkit to get started.</li> </ul>"},{"location":"azure/#deployed-resources","title":"Deployed Resources","text":"<p>The template will deploy in your Azure subscription the Following resources:  </p> <ul> <li>IoT Hub</li> <li>Azure Function and Consumption Service Plan</li> <li>Redis Cache</li> <li>Application Insights</li> <li>Log Analytics (when opted in to use Azure Monitor)</li> <li>Azure WebApp and Service Plan</li> <li>Azure Database for PostgreSQL</li> </ul>"},{"location":"azure/#instructions","title":"Instructions","text":"<ol> <li> <p>Choose a solution prefix for your Azure Deployment.</p> </li> <li> <p>Configure your AD to connect to the portal.     Use Portal AD applications configuration page to configure your AD B2C Tenant :</p> <p>You should have recorded the following information:  </p> <ul> <li>OpenID authority: <code>&lt;your-openid-authority&gt;</code> </li> <li>OpenID metadata URL: <code>&lt;your-openid-provider-metadata-url&gt;</code> </li> <li>Client ID: <code>&lt;your-client-id&gt;</code> </li> <li>API Client ID: <code>&lt;your-client-id&gt;</code></li> </ul> </li> <li> <p>Press on the button here below to start your deployment on Azure: </p> </li> <li> <p>You will get to a page asking you to fill the following fields:</p> <ul> <li>Resource Group: A logical \"folder\" where all the template resource would be put into, just choose a meaningful name.</li> <li>Location: In which DataCenter the resources should be deployed. Make sure to choose a location where IoT Hub is available</li> <li>Unique Solution Prefix: A string that would be used as prefix for all the resources name to ensure their uniqueness.</li> <li>PostgreSQL user: The PostgreSQL user name to be used for the IoT Hub Portal database.</li> <li>PostgreSQL password: The PostgreSQL password to be used for the IoT Hub Portal database.</li> <li>Confirm PostgreSQL password: The PostgreSQL password to be used for the IoT Hub Portal database.</li> <li>Open Id Authority: The OpenID authority used by the portal.</li> <li>OpenId Metadata URL: The OpenID metadata URL used by the portal.</li> <li>Client Id: the ID of the web client that will be used to authenticate the portal.</li> <li>Api Client Id: the ID of the API client that will be used to authenticate the portal.</li> <li>Edge gateway name: the name of your LoRa Gateway node in the IoT Hub.</li> <li>Deploy Device: Do you want demo end devices to be already provisioned (one using OTAA and one using ABP)? If yes set this to true, the code located in the Arduino folder would be ready to use immediately.</li> <li>Reset pin:  The reset pin of your gateway (the value should be 7 for the Seed Studio LoRaWan, 25 for the IC880A)</li> <li>Region:  In what region are you operating your device (currently only EU868 and US915 is supported)</li> </ul> <p>see: https://azure.github.io/iotedge-lorawan-starterkit/dev/quickstart/#deployed-azure-infrastructure for more information about the LoRaWan IoT Hub and Azure deployment.</p> </li> </ol>"},{"location":"azure/#configurationssecrets","title":"Configurations/Secrets","text":"<p>Secrets are used to fill in the login credentials to the cloud platform. You have to enter them in a <code>json</code> file to be able to connect to the IoT Hub Portal. Here is a template of a such <code>json</code> file :</p> JSON<pre><code>{\n  \"CloudProvider\": \"Azure\",\n  \"OIDC:Scope\": \"&lt;SCOPE&gt;\",\n  \"OIDC:MetadataUrl\": \"&lt;METADATA_URL&gt;\",\n  \"OIDC:ClientId\": \"&lt;CLIENT_ID&gt;\",\n  \"OIDC:Authority\": \"&lt;AUTHORITY&gt;\",\n  \"OIDC:ApiClientId\": \"&lt;API_CLIENT_ID&gt;\",\n  \"LoRaFeature:Enabled\": \"&lt;TRUE_OR_FALSE&gt;\",\n  \"Azure:LoRaRegionRouterConfig:Url\": \"&lt;LORA_WAN_ROUTER_CONFIGURATION_URL&gt;\",\n  \"Azure:LoRaKeyManagement:Url\": \"&lt;LORA_WAN_KEY_MANAGEMENT_URL&gt;\",\n  \"Azure:LoRaKeyManagement:Code\": \"&lt;LORA_WAN_KEY_MANAGEMENT_CODE&gt;\",\n  \"Kestrel:Certificates:Development:Password\": \"&lt;DEV_PASSWORD&gt;\",\n  \"Azure:IoTHub:ConnectionString\": \"&lt;IOT_HUB_CONNECTION_STRING&gt;\",\n  \"Azure:IoTHub:EventHub:Endpoint\": \"&lt;IOT_HUB_EVENT_HUB_ENDPOINT&gt;\",\n  \"Azure:IoTHub:EventHub:ConsumerGroup\": \"&lt;IOT_HUB_EVENT_HUB_CONSUMER_GROUP&gt;\",\n  \"Azure:IoTDPS:ServiceEndpoint\": \"&lt;SERVICE_END_POINT&gt;\",\n  \"Azure:IoTDPS:LoRaEnrollmentGroup\": \"&lt;LORA_WAN_ENROLLMENT_GROUP&gt;\",\n  \"Azure:IoTDPS:DefaultEnrollmentGroup\": \"&lt;LORA_WAN_DEFAULT_ENROLLMENT_GROUP&gt;\",\n  \"Azure:IoTDPS:ConnectionString\": \"&lt;IOT_DPS_CONNECTION_STRING&gt;\",\n  \"PostgreSQL:ConnectionString\": \"&lt;POSTGRE_SQL_CONNECTION_STRING&gt;\",\n  \"Azure:StorageAccount:ConnectionString\": \"&lt;CONNECTION_STRING_STORAGE_ACCOUNT&gt;\"\n}\n</code></pre> <p>Note: You must replace all values in the brackets by your own Azure settings. If you can't find them in the Azure Portal, please contact an administrator of this project to have more information.</p> <p>This <code>json</code> file must be added into your project solution. To do that, click on the <code>AzureIoTHub.Server</code> project in Visual Studio and select <code>Manage User Secrets</code> from the context menu. You can now add your secrets inside this file.</p> <p>You are now ready to start your IoT Hub Portal development !</p>"},{"location":"b2c-applications/","title":"Azure AD B2C Tenant with applications","text":"<p>This solution uses Azure AD B2C to authenticate the portal. In this page you will configure the B2C tenant and two applications (API and Web UI).</p> <p>By the end, you should have recorded the following information:</p> Text Only<pre><code>* OpenID authority: `&lt;your-openid-authority&gt;`\n* OpenID metadata URL: `&lt;your-openid-provider-metadata-url&gt;`\n* Client ID: `&lt;your-client-id&gt;`\n* API Client ID: `&lt;your-client-id&gt;`\n</code></pre>"},{"location":"b2c-applications/#step-by-step-instructions","title":"Step by Step instructions","text":"<ol> <li> <p>Create an Azure AD B2C Tenant (see: https://docs.microsoft.com/en-us/azure/active-directory-b2c/tutorial-create-tenant#create-an-azure-ad-b2c-tenant)</p> <ul> <li>Record the tenant ID and the tenant name.</li> </ul> </li> <li> <p>After creating your Azure AD B2C Tenant and registering your applications, you need to set up OpenID Connect to secure your applications. Here\u2019s how to find your OpenID authority and OpenID metadata URL:</p> <ol> <li>Determine your OpenID Authority:<ul> <li>Your OpenID Authority is the issuer URL of your Azure AD B2C Tenant. It typically follows the format: <code>https://&lt;tenant-name&gt;.b2clogin.com/&lt;tenant-name&gt;.onmicrosoft.com/v2.0/</code>.</li> <li>Replace <code>&lt;tenant-name&gt;</code> with your actual tenant name.</li> </ul> </li> <li>Find your OpenID Metadata URL:<ul> <li>The OpenID Metadata URL for Azure AD B2C tenants is usually in the format: <code>https://&lt;tenant-name&gt;.b2clogin.com/&lt;tenant-name&gt;.onmicrosoft.com/v2.0/.well-known/openid-configuration?p=&lt;policy-name&gt;</code>.</li> <li>Replace <code>&lt;tenant-name&gt;</code> and <code>&lt;policy-name&gt;</code> with your actual tenant name and the policy name you are using (like B2C_1_SignUpSignIn).</li> </ul> </li> <li>Make sure to record the OpenID authority and OpenID metadata URL for future configuration steps.</li> </ol> </li> <li> <p>Configure the requiered AD Applications.</p> <ol> <li> <p>Create the IoT Hub Portal API Application:</p> <ul> <li>Select App registrations, and then select New registration.</li> <li>Enter a Name for the application. For example, IoT Hub Portal.</li> <li>Under Redirect URI, select Web, and then enter an expected endpoint for your portal (ex: https://tenantName.b2clogin.com/tenantName.onmicrosoft.com/oauth2/authresp)</li> <li>Select Register.</li> <li>Record the Application (client) ID for use in your web API's code.</li> <li>Under Manage, select Certificates &amp; Secrets.</li> <li>Under Client secret, select New client secret.</li> <li>Enter a name for the secret.</li> <li>Record the Client secret for use in your web API's code.</li> <li>Under Manage, select API permissions.</li> <li>Under Configured permissions, select Add a permission.</li> <li>Select the Microsoft APIs tab.</li> <li>Under Commonly used Microsoft APIs, select Microsoft Graph.</li> <li>Select Application permissions.</li> <li>Under Application permissions, expand User, then select:<ul> <li><code>User.Invite.All</code></li> <li><code>User.ManageIdentities.All</code></li> <li><code>User.Read.All</code></li> <li><code>User.ReadWrite.All</code></li> </ul> </li> <li>Select Add permission.</li> <li>If you're prompted to select an account, select your currently signed-in administrator account, or sign in with an account in your Azure AD B2C tenant that's been assigned at least the Cloud application administrator role.</li> <li>Under Manage, select Expose an API.</li> <li>Next to Application ID URI, select the Set link.</li> <li>Under Scopes defined by this API, select Add a scope.</li> <li>Enter the following values to create a scope that defines read access to the API, then select Add scope:<ul> <li>Scope name: <code>API.Access</code> (this is the name of the scope that will be used in the template)</li> <li>Admin consent display name: <code>Access to the Portal API</code></li> <li>Admin consent description: <code>Allows the application to get access to the Portal API</code></li> </ul> </li> </ul> </li> <li> <p>Create the IoT Hub Portal Client Application:</p> <ul> <li>Select App registrations, and then select New registration.</li> <li>Enter a Name for the application. For example, IoT Hub Portal Client.</li> <li>Under Redirect URI, select Web, and then enter an expected endpoint for your portal (ex: https://**solutionPrefix**portal.azurewebsites.net/authentication/login-callback)</li> <li>Select Register.</li> <li>Record the Application (client) ID for use in your web client.</li> <li>Select App registrations, and then select the web application that should have access to the API.</li> <li>Under Manage, select API permissions.</li> <li>Under Configured permissions, select Add a permission.</li> <li>Select the My APIs tab.</li> <li>Select the API to which the web application should be granted access.</li> <li>Under Permission, expand API, and then select the scope that you defined earlier.</li> <li>Select Add permissions.</li> <li>Select Grant admin consent for (your tenant name).</li> <li>If you're prompted to select an account, select your currently signed-in administrator account, or sign in with an account in your Azure AD B2C tenant that's been assigned at least the Cloud application administrator role.</li> <li>Select Yes.</li> <li>Select Refresh, and then verify that \"Granted for ...\" appears under Status for both scopes.</li> </ul> </li> </ol> </li> <li> <p>Configure the required User flow:</p> <ol> <li>Select User flows, and then select New user flow.</li> <li>Under Select a user flow type, select Sign in, then select Create.</li> <li>Enter a name for the flow SignIn, then select Create.</li> </ol> </li> </ol>"},{"location":"concepts/","title":"Core Concepts","text":"<p>The Azure IoT Hub portal inherits from Azure IoT Hub concepts to manage IoT devices.</p> <p>It relies on the following concepts:</p> <ul> <li>IoT Device Provisioning</li> <li>IoT Hub Device Twin</li> <li>IoT Hub Device Twin properties</li> <li>IoT Hub Edge deployment manifest</li> <li>Cloud To Device Message</li> </ul>"},{"location":"concepts/#device-models","title":"Device models","text":"<p>By using this capability, the application can create logical representations of IoT devices. This feature is designed to configure a set of sharable properties between devices. When creating a device, the user is asked to specify the device model. The application will then apply the properties of the device model to the device.</p> <p></p>"},{"location":"concepts/#parameters","title":"Parameters","text":"<ul> <li><code>Device Model Id</code>: The ID of the device model.     &gt; Note: Since the device model is shared among all the devices, theID should be unique. For convenience, the ID is generated by the application. By using the API, the ID is not required, but if provided, it will be used as the ID of the device model.</li> <li><code>Name</code>: The name of the device model.</li> <li><code>Description</code>: The description of the device model.</li> </ul>"},{"location":"concepts/#built-in-models","title":"Built-in models","text":"<p>Built-in models are predefined device models that can be used by the application. This functionality is exactly the same as standard device models except that the properties are not editable and the device model is not removable via the Portal.</p> <p>Note: Creating and updating built-in models is not available in the portal. They can be managed using the Azure IoT Hub portal APIs.</p> <p>See Device Model API reference for more information.</p>"},{"location":"concepts/#devices","title":"Devices","text":"<p>Devices are the physical IoT devices that are provisioned by the application. They are represented by an object that is stored in the Azure IoT Hub as the device twin.</p> <p></p>"},{"location":"concepts/#device-parameters","title":"Device Parameters","text":"<ul> <li><code>Device Id</code>: The ID of the device.     &gt; Note: It is the device id stored in the Azure IoT Hub. It is asked to the user when creating a device and is not editable after the device is created.</li> <li><code>Name</code>: The name of the device model.     &gt; Note: The device name is the device friendly name. The name is editable after the device is created.</li> <li><code>Device Model</code>: The device model that the device is based on.     &gt; Note: The device model is asked to the user during the device creation and is not editable after the device is created.</li> <li><code>Status</code>: The status of the device.     &gt; Note: The status is related to the Device status in the Azure IoT Hub.</li> <li><code>Tags</code>: The tags of the device.     &gt; Note: The tags are related to the Device tags in the Azure IoT Hub. They could be defined at the portal level and set to the device for filtering and targeting for configuration.</li> </ul>"},{"location":"concepts/#device-twin-tags","title":"Device Twin tags","text":"<p>To store additional information about the device, the application uses device twin tags.</p> Name Position Description deviceName <code>tags.deviceName</code> Field that contains the device friendly name.note: if not set, the portal will show the device id instead of the device name until it's configured. modelId <code>tags.modelId</code> Field that contains the device model identifier that the device is related.note: if not set, the device is not usable on the IoT hub portal. supportLoRaFeatures <code>tags.supportLoRaFeatures</code> Field that specifies if the device must support LoRa features.note: if not set, LoRa features will be available on the device."},{"location":"concepts/#iot-edge","title":"IoT Edge","text":"<p>IoT Edge is fully herited from Azure IoT Hub concepts. In the portal, the user can mangage the IoT Edge devices stored in Azure IoT Hub. For more information about Azure IoT Edge, see Azure IoT Edge documentation.</p> <p></p>"},{"location":"concepts/#iot-edge-parameters","title":"IoT Edge Parameters","text":"<ul> <li><code>Type</code>: The type of the IoT Edge device.     &gt; Note: related to the IoT Edge purpose tag value that might be used to create deployment manifests.</li> <li><code>Environment</code>: The IoT Edge device environment (Development, Production, QA).     &gt; Note: this is an additional field that can be used to create deployment manifests.</li> <li><code>Status</code>: The status of the device.     &gt; Note: The status is related to the Device status in the Azure IoT Hub.</li> <li><code>Nbr of connected devices</code>: The number of devices connected to the IoT Edge device.     &gt; Note: The number of connected devices is related to the number of connections that are currently present in the edgeHub module. This might be different from the number of devices connected to the IoT Edge device if some modules are using edgeHub connections.</li> <li><code>Nbr of desired modules</code>: The number of modules that are desired in the last deployment.</li> </ul>"},{"location":"concepts/#last-deployment","title":"Last deployment","text":"<p>The last deployment section shows information about the deployment manifest that is currently applied to the IoT Edge device.</p>"},{"location":"concepts/#iot-edge-module","title":"IoT Edge Module","text":"<p>The IoT Edge module section represents the modules that are currently deployed on the IoT Edge device. It doesn't include the system modules of IoT Edge (edgeAgent and edgeHub). With the portal, the user can interact with these modules and manage them (Get last module logs, restart module, etc.).</p>"},{"location":"concepts/#iot-edge-device-twin-tags","title":"IoT Edge Device Twin tags","text":"<p>To store additional information about the device, the application uses device twin tags.</p> Name Position Description Environment <code>tags.env</code> Field that contains the Device Environment value.note: this tag may be used to target deployment manifests for the IoT Edge Type <code>tags.type</code> Field that contains The type of the IoT Edge device.note: this tag may be used to target deployment manifests for the IoT Edge"},{"location":"concepts/#dps-enrollment-groups","title":"DPS Enrollment groups","text":"<p>The IoT Hub portal relies on Azure Device Provisioning Enrollement groups to manage IoT Edge device connection strings. When clicking on \"Connect\" in the IoT Edge details page, the user can access the device unique credentials in the enrollment group.</p> <p>Note: see Provision the device with its cloud identity  to know how to configure the IoT Edge to use these credentials to connect to the platform.</p>"},{"location":"concepts/#device-configuration","title":"Device Configuration","text":"<p>By using the portal, users can manage the device configuration and deploy to devices that are targeted by the configuration.</p> <p></p> <p>It relies on the Device Model to define the configuration parameters that can be deployed to the devices.</p>"},{"location":"concepts/#device-configuration-template","title":"Device Configuration template","text":"<p>Under the cover, the configuration is stored in the Azure IoT Hub as the  twin configuration.</p> JSON<pre><code>{\n    \"id\": \"&lt;configuration-name&gt;-&lt;timestamp&gt;\",\n    \"schemaVersion\": \"1.0\",\n    \"labels\": {\n        \"created-by\": \"Azure IoT hub Portal\",\n        \"configuration-id\": \"&lt;configuration-name&gt;\"\n    },\n    \"content\": {\n        \"deviceContent\": {\n            \"properties.desired.**\": **\n        }\n    },\n    \"targetCondition\": \"tags.modelId = '&lt;The model identifier&gt;' and tags.** = '**' AND ...\",\n    \"createdTimeUtc\": \"2022-06-13T07:32:19.7376998Z\",\n    \"lastUpdatedTimeUtc\": \"2022-06-13T07:32:19.7376998Z\",\n    \"priority\": 100\n}\n</code></pre> <p>Please note that the <code>created-by</code> label is used to identify the configuration created by the IoT Hub portal.</p>"},{"location":"concepts/#iot-edge-configuration","title":"IoT Edge Configuration","text":"<p>The IoT Edge configuration concerns the IoT Edge deployment manifests that are currently present in the IoT Hub. The portal can be used to see the details of the configurations.</p> <p>Note: At this time the portal cannot be used to update the configurations.</p> <p></p>"},{"location":"concepts/#target","title":"Target","text":"<p>The parameters are related to the IoT Edge deployment manifest target condition field. The IoT Hub portal will use the Target condition to extract this values from the deployment manifest.</p> Name Position Description Owner <code>tags.owner</code> Owner tag filter condition from the Deployment Manifest. Environment <code>tags.env</code> Environment tag filter from the Deployment Manifest. Type <code>tags.type</code> Device type tag filter from the Deployment Manifest. Expected value for IoT Edge LoRaWAN LNS is <code>LoRa Network Server</code>, otherwise the value must be <code>Other</code>"},{"location":"concepts/#enrollment-groups","title":"Enrollment groups","text":"<p>The IoT Hub portal relies on Azure Device Provisioning Enrollment groups to manage IoT device connection credentials.</p> <p>For each device model, the portal will create a new enrollment group with symmetric key attestation. By clicking on \"Connect\" in the device details page, the portal will show unique credentials to the device for the corresponding enrollment group.</p> <p>Furthermore, the enrollment group is configured to provide initial device twin state:</p> JSON<pre><code>{\n  \"tags\": {\n    \"modelId\": \"......\"\n  },\n  \"properties\": {\n    \"desired\": {}\n  }\n}\n</code></pre> <p>For more information, see Azure Device Provisioning Enrollement groups.</p>"},{"location":"concepts/#lorawan","title":"LoRaWAN","text":"<p>LoRaWAN features are activated by default, providing a way to configure IoT Devices that supports LoRaWAN connectivity in the Portal. Internally, the LoRaWAN connectivity is expected to be provided by IoTEdge LoRaWAN StarterKit. The IoT Hub portal will manage devices by modifying their twin properties to make them working with this solution.</p> <p>Note: to disable LoRa Features, change the value of <code>LoRaFeature__Enabled</code> to false in the Portal App Settings.</p>"},{"location":"concepts/#lorawan-device-models","title":"LoRaWAN Device Models","text":"<p>For regular Device Models the IoT hub portal provides the possibility to manage LoRaWAN device models. To activate the LoRaWAN features on the device model, the user have to enable the option in the <code>LoRa Device</code> section</p> <p></p> <p>Note: once activated, the device model detail adds a new tab called \"LORAWAN\" that adds new settings to the device model.</p> <p></p>"},{"location":"concepts/#lorawan-device-model-parameters","title":"LoRaWAN Device Model Parameters","text":"<p>The parameters for the device models are parameters that are stored in the IoT Hub portal and retrieved for devices that inherits from this device model.</p> <p>Note: When changing the value of a parameter, the device will be updated with the new value. In that case, user should then modify each device and re-save it to get the correct properties.</p> <ul> <li><code>Support OTAA/ABP setting</code>: The device model supports OTAA/ABP connectivity.</li> <li><code>Type</code>: The LoRaWAN device class type (A or C).</li> <li><code>Message Deduplication</code>: Allows controlling the handling of duplicate messages received by multiple gateways.The default is Drop.</li> <li><code>OTAA AppEUI</code>: The device model OTAA App EUI used for the device during the OTAA Join procedure.</li> <li><code>Sensor Decoder URL</code>: The Sensor Decoder URL that the network server should use to decode frames comming from the devices that inherit from this model.</li> <li><code>Device Connection Timeout</code>: Allows defining a sliding expiration to the connection between the leaf device and IoT/Edge Hub. The default is none, which causes the connection to not be dropped.</li> <li><code>Support downstream messages</code>: Allows controlling the support of downstream messages. The default is false.</li> <li><code>Preferred receive window</code>: Allows setting the device preferred receive window (RX1 or RX2). The default preferred receive window is 1</li> <li><code>RX Delay</code>: Allows setting a custom wait time between receiving and transmission as specified in the specification.</li> <li><code>RX1 Data offset</code>: Allows setting a custom data offset for the RX1 receive window. The default is 0.</li> <li><code>RX2 Data rate</code>: Allows setting a custom data rate for the RX2 receive window. The default is 0.</li> <li><code>32bit counter support</code>: Allow the usage of 32bit counters on your device.</li> <li><code>Frame counter up start value</code>: Allows setting the frame counter start value for upstream messages. The default is 0.</li> <li><code>Frame counter down start value</code>: Allows setting the frame counter start value for downstream messages. The default is 0.</li> <li><code>Frame counter reset value</code>: Allows to reset the frame counters to the FCntUpStart/FCntDownStart values respectively.</li> </ul> <p>Note: for more information about LoRaWAN properties, please refer to the LoRaWAN StarterKit Documentation</p>"},{"location":"concepts/#commands","title":"Commands","text":"<p>The devices commands are pre-stored frames that the user can add to the device model and then will be able to use on the device detail page to launch to the device.</p> <ul> <li><code>Name</code>: The command name. This name is only a friendly name that the user can set to understand what the command is supposed to do.</li> <li><code>Frame</code>: The LoRaWAN frame (in hex) to be sent to the device.</li> </ul>"},{"location":"concepts/#lorawan-devices","title":"LoRaWAN Devices","text":"<p>LoRaWAN devices are accessible from the IoT Hub portal for devices that inherits from the LoRaWAN device model. The LoRaWAN tab shows the device details.</p> <p></p> <p>Note: By selecting the correct device model on the first tab, the portal will automatically take LoRaWAN settings from the device model to apply on the device.</p>"},{"location":"concepts/#concentrators","title":"Concentrators","text":""},{"location":"concepts/#concentrator-parameters","title":"Concentrator Parameters","text":"<ul> <li><code>Device ID</code>: The Station EUI for the LoRaWan Basic station.</li> <li><code>Device Name</code>: The friendly name for the device.</li> <li><code>Client Certificate Thumbprint</code>: The client certificate thumbprint used by the Basic Station to authenticate to the LoRaWAN Network Server.</li> <li><code>Region</code>: The LoRaWAN region used by the Basic Station (EU868, US915, AS923 and CN470 supported).</li> </ul>"},{"location":"concepts/#concentrator-tags","title":"Concentrator Tags","text":"<p>To store additional information about the concentrator, the application will use the target device to extract values:</p> Name Position Description Device Name <code>tags.deviceName</code> Field that contains the Device name. Region <code>tags.loraRegion</code> Field that contains the Device region. deviceType <code>tags.deviceType</code> Field that contains The type of device. Expected value is <code>LoRa Concentrator</code>"},{"location":"concepts/#command-execution","title":"Command Execution","text":"<p>To execute the command, the device should have joined the network. The message below explains that the device have to be connected to the network ant commands are disabled until the device is connected to the network.</p> <p></p>"},{"location":"concepts/#command-execution-flow","title":"Command execution flow","text":"<p>The schema below explain how the command execution flow works.</p>  sequenceDiagram     User-&gt;&gt;+IoT Hub Portal: Send Command (DeviceId, FrameId)     IoT Hub Portal-&gt;&gt;+LoRa Key Management Facade: POST /api/cloudtodevicemessage     LoRa Key Management Facade-&gt;&gt;+Azure IoT Hub: Invoke Device Method to Network Server     Azure IoT Hub--&gt;&gt;-LoRa Key Management Facade: Cloud To Device Method Result     LoRa Key Management Facade--&gt;&gt;-IoT Hub Portal: Send Cloud To Device Message Result     IoT Hub Portal--&gt;&gt;-User: Command send result  <p>See https://azure.github.io/iotedge-lorawan-starterkit/2.0.0/quickstart/#cloud-to-device-message for more information about the Cloud To Device Message involed  in the LoRa WAN device commands execution flow.</p>"},{"location":"concepts/#automatic-device-configuration-for-lora-wan","title":"Automatic device configuration for LoRa WAN","text":"<p>When modifying the device model, the IoT Hub portal will automatically create a new Device Configuration that will target the IoT devices that have the corresponding <code>modelId</code> tag.</p> <p>The IoT Hub portal will create a new Rollout deployment that will remove older configuration and add the new configuration.</p> <p>This process ensure that the devices twin will be updated at scale by the IoT hub and each devices that inherit for the model will be updated according the model configuration.</p> <p>The configuration will be created with the following schema:</p> JSON<pre><code>{\n    \"id\": \"&lt;model-name&gt;-&lt;timestamp&gt;\",\n    \"schemaVersion\": \"1.0\",\n    \"labels\": {\n        \"created-by\": \"Azure IoT hub Portal\"\n    },\n    \"content\": {\n        \"deviceContent\": {\n            \"properties.desired.AppEUI\": \"&lt;The Device Model OTAA AppEUI&gt;\",\n            \"properties.desired.SensorDecoder\": \"&lt;The Device Model Sensor Decoder&gt;\"\n        }\n    },\n    \"targetCondition\": \"tags.modelId = '&lt;The model identifier&gt;'\",\n    \"createdTimeUtc\": \"2022-02-28T20:29:39.128Z\",\n    \"lastUpdatedTimeUtc\": \"2022-02-28T20:29:39.128Z\",\n    \"priority\": 0\n}\n</code></pre> <p>Please note that the <code>created-by</code> label is used to identify the configuration created by the IoT Hub portal.</p> <p>For more information see Automatic IoT device and module management.</p>"},{"location":"dev-guide/","title":"Developer Guide","text":""},{"location":"dev-guide/#directory-structure","title":"Directory Structure","text":"<p>The code is organized into the following directory structure:</p> <ul> <li>src: Source code</li> <li>AzureIoTHub.Portal.Server.Tests: Unit test project for the Portal</li> <li>AzureIoTHub.Portal: The Portal project<ul> <li>Client: .NET 6 Blazor Web Assembly project that alow to visualize the IoT Hub data</li> <li>Server: .NET 6 Web API project that provides the API for the Portal</li> <li>Shared: Shared code between the Client and Server projects</li> </ul> </li> <li>templates: contains the templates for the \"deploy to Azure\" button</li> </ul>"},{"location":"dev-guide/#overall-architecture","title":"Overall Architecture","text":"<p>This schema represent the various components and how they interact to have a better understanding of the various solution elements.</p> <p></p> <ol> <li>The user is authenticated by the OpenID Connect server.</li> <li>The user access to the IoT Hub Portal with the OAuth2.0 token.</li> <li>The IoT Hub portal uses the Azure IoT Hub REST API to retrieve the data.</li> <li>The IoT Hub portal uses the Azure Device Provisioning Service to manage IoT Edge devices.</li> <li>The IoT Hub portal uses the Azure Storage account to store the device models configuration (Images, Commands, etc.).</li> <li>The IoT Hub portal uses the LoRa Key Management Facade to send Cloud to Device (C2D) messages to LoRa devices.</li> <li>The LoRa Key Management Facade uses Redis to store its cached data.</li> <li>The LoRa Key Management Facade uses the Azure IoT Hub REST API to retrieve the LoRa device keys and send C2D messages.</li> <li>The IoT Hub portal synchronizes its data with the IoT Hub to provide a consistent view of the data.</li> </ol> <p>Note: For more information about the LoRa Key Management Facade, see the Azure IoT Edge LoRaWAN Starter Kit page.</p>"},{"location":"dev-guide/#prerequisites","title":"Prerequisites","text":"<p>The following should be completed before proceeding with the IoT Hub Portal development or deployment in your environment.</p> <p>Before getting started, it is better to master the tools below:</p> <ul> <li>Azure platform and Azure IoT Hub. A tutorial can be found here.</li> <li>Blazor WebAssembly and Blazor Server. A traning is available on this site.</li> <li>Docker. An introduction to containerization is available on this page.</li> <li>IoTEdge LoraWAN StarterKit. Have a look at LoRaWAN Starter Kit to get more details on this OSS cross platform private network.</li> </ul> <p>Once you know the basics of these technologies and tools, you must follow these last steps to set up your working environment.</p> <ul> <li>IoT Hub Portal uses containers to work correctly. Docker is required to launch this project (version &gt;= 4.11.1).</li> </ul> <p>Once you have download Docker, you must install the WSL 2 Linux kernel. To do that, please refer to the official Microsoft documentation. You can choose the linux distribution of your choice, for example Ubuntu.</p> <ul> <li>Node.js is used to run JavaScript code in the portal. You can download the latest version here.The minimal version required is 16.17.0.</li> <li>You must have an Azure subscription. Get an Azure Free account to start.</li> <li>An Identity provider supporting OpenIDConnect protocol configured with 2 applications (API and web) is required to login to the IoT Hub Portal. See Azure AD B2C Tenant with applications configuration page for example.</li> <li>To develop, you can choose your own IDE or text editor, for example Visual Studio.</li> </ul>"},{"location":"dev-guide/#secrets","title":"Secrets","text":"<p>Secrets are used to fill in the login credentials to the cloud platform. You have to enter them in a <code>json</code> file to be able to connect to the IoT Hub Portal. Here is a template of a such <code>json</code> file :</p> JSON<pre><code>{\n  \"StorageAccount:ConnectionString\": \"&lt;CONNECTION_STRING_STORAGE_ACCOUNT&gt;\",\n  \"StorageAccount:BlobContainerName\": \"&lt;BLOB_CONTAINER_NAME&gt;\",\n  \"OIDC:Scope\": \"&lt;SCOPE&gt;\",\n  \"OIDC:MetadataUrl\": \"&lt;METADATA_URL&gt;\",\n  \"OIDC:ClientId\": \"&lt;CLIENT_ID&gt;\",\n  \"OIDC:Authority\": \"&lt;AUTHORITY&gt;\",\n  \"OIDC:ApiClientId\": \"&lt;API_CLIENT_ID&gt;\",\n  \"LoRaRegionRouterConfig:Url\": \"&lt;LORA_WAN_ROUTER_CONFIGURATION_URL&gt;\",\n  \"LoRaKeyManagement:Url\": \"&lt;LORA_WAN_KEY_MANAGEMENT_URL&gt;\",\n  \"LoRaKeyManagement:Code\": \"&lt;LORA_WAN_KEY_MANAGEMENT_CODE&gt;\",\n  \"LoRaFeature:Enabled\": \"&lt;TRUE_OR_FALSE&gt;\",\n  \"Kestrel:Certificates:Development:Password\": \"&lt;DEV_PASSWORD&gt;\",\n  \"IoTHub:ConnectionString\": \"&lt;IOT_HUB_CONNECTION_STRING&gt;\",\n  \"IoTHub:EventHub:Endpoint\": \"&lt;IOT_HUB_EVENT_HUB_ENDPOINT&gt;\",\n  \"IoTHub:EventHub:ConsumerGroup\": \"&lt;IOT_HUB_EVENT_HUB_CONSUMER_GROUP&gt;\",\n  \"IoTDPS:ServiceEndpoint\": \"&lt;SERVICE_END_POINT&gt;\",\n  \"IoTDPS:LoRaEnrollmentGroup\": \"&lt;LORA_WAN_ENROLLMENT_GROUP&gt;\",\n  \"IoTDPS:DefaultEnrollmentGroup\": \"&lt;LORA_WAN_DEFAULT_ENROLLMENT_GROUP&gt;\",\n  \"IoTDPS:ConnectionString\": \"&lt;IOT_DPS_CONNECTION_STRING&gt;\",\n  \"PostgreSQL:ConnectionString\": \"&lt;POSTGRE_SQL_CONNECTION_STRING&gt;\"\n}\n</code></pre> <p>Note: You must replace all values in the brackets by your own Azure settings. If you can't find them in the Azure Portal, please contact an administrator of this project to have more information.</p> <p>This <code>json</code> file must be added into your project solution. To do that, click on the <code>AzureIoTHub.Server</code> project in Visual Studio and select <code>Manage User Secrets</code> from the context menu. You can now add your secrets inside this file.</p> <p>You are now ready to start your IoT Hub Portal development !</p>"},{"location":"dev-guide/#iot-hub-portal-configuration","title":"IoT Hub Portal Configuration","text":"<p>By deploying the IoT Hub Portal, the user can configure the IoT Hub and the LoRaWAN network.</p> <p>Since the IoT Hub Portal is deployed as a Docker container, the application settings can be configured with environment variables.</p>"},{"location":"dev-guide/#application-settings","title":"Application settings","text":"<p>Here are different settings that the user can configure:</p> <ul> <li>PortalName: The name of the portal (shown in the App Bar and the Page Title).</li> <li>OIDC__Authority: The OpenID Connect issuer.</li> <li>OIDC__MetadataUrl: The OpenID Connect metadata URL (e.g. <code>.well-known/openid-configuration</code>).</li> <li>OIDC__ClientId: The OpenID Connect client ID for the Web UI.</li> <li>OIDC__ApiClientId: The OpenID Connect client ID for the API.</li> <li>OIDC__Scope: The OpenID Connect scope that represents the portal API.</li> <li>IoTDPS__ServiceEndpoint: The IoT Device Provisioning Service endpoint.</li> <li>IoTDPS__IDScope: The IoT Device Provisioning Service ID scope.</li> <li>LoRaFeature__Enabled: Whether the LoRaWAN feature is enabled or not.</li> <li>LoRaKeyManagement__Url: The LoRa Key Management Facade URL.</li> <li>StorageAccount__BlobContainerName: The name of the Azure Storage container where the device models images are stored.</li> <li>IoTHub__EventHub__Endpoint: The IotHub Event Hub compatible endpoint.</li> <li>IoTHub__EventHub__ConsumerGroup: (Default value <code>iothub-portal</code>) The name of the consumer group used to to pull data from the IoT Hub (Automatically created by the Bicep/ARM deployement)</li> <li>ASPNETCORE_ENVIRONMENT: Built-in environment variable, used to target the configuration provided by a specific environment. Two accepted values:</li> <li><code>Development</code>: On this environment, logs are produced up to <code>Debug</code> level.</li> <li><code>Production</code>: Default value if ASPNETCORE_ENVIRONMENT is not set. On this environment, logs are produced up to <code>Information</code> level.</li> <li>Metrics__ExporterRefreshIntervalInSeconds: (Optional, default value <code>30</code>) The refresh interval in <code>seconds</code> to collect custom metrics and expose them to the exporter endpoint.</li> <li>Metrics__LoaderRefreshIntervalInMinutes: (Optional, default value <code>10</code>) The refresh interval in <code>minutes</code> to calculate/refresh custom metrics values.</li> <li>Ideas__Enabled: (Optional, default value <code>false</code>) To enable Ideas feature when set to <code>true</code>.</li> <li>Ideas__Url: Url of <code>Awesome-Ideas</code>, to publish ideas submitted by users.</li> <li>Ideas__Authentication__Header: (Optional, default value <code>Ocp-Apim-Subscription-Key</code>) Authentication header name.</li> <li>Ideas__Authentication__Token: Authentication token.</li> <li>Job__SyncDatabaseJobRefreshIntervalInMinutes: (Optional, default value <code>5</code>) The refresh interval in <code>minutes</code> to collect data from Azure IoT Hub (Devices, Iot Edge Devices...) and store them on the database of the Portal.</li> </ul>"},{"location":"dev-guide/#connection-strings","title":"Connection strings","text":"<p>Here are different connection strings that the user can configure:</p> <ul> <li>IoTHub__ConnectionString: The connection string to the IoT Hub.</li> <li>IoTDPS__ConnectionString: The connection string to the Azure IoT Device Provisioning Service.</li> <li>StorageAccount__ConnectionString: The connection string to the Azure Storage account.</li> <li>LoRaKeyManagement__Code: The LoRa Key Management Facade code.</li> <li>PostgreSQL__ConnectionString: The connection string allowing the connection to the PostgreSQL database.</li> </ul> <p>Note: For a production environment, an Azure Key Vault is advised to store the connection strings.</p>"},{"location":"dev-guide/#optional-security-settings","title":"Optional Security Settings","text":"<p>There are several optional security settings that the user can configure. These settings are not required for the Portal to work. By default the Portal is configured to set security levels to <code>Microsoft.IdentityModel.Tokens</code> defaults but the user can override these settings.</p> <ul> <li>UseSecurityHeaders <p>This boolean adds the following headers to all responses :</p> <p><code>X-Content-Type-Options: nosniff</code></p> <p><code>Strict-Transport-Security: max-age=31536000; includeSubDomains</code> - only applied to HTTPS responses</p> <p><code>X-Frame-Options: Deny</code> - only applied to text/html responses</p> <p><code>X-XSS-Protection: 1; mode=block</code> - only applied to text/html responses</p> <p><code>Referrer-Policy: strict-origin-when-cross-origin</code> - only applied to text/html responses</p> <p><code>Content-Security-Policy: object-src 'none'; form-action 'self'; frame-ancestors 'none'</code> - only applied to text/html responses.</p> <p>The default is true.</p> </li> <li>OIDC__ValidateIssuer <p>Validation of the issuer mitigates forwarding attacks that can occur when an IdentityProvider represents multiple tenants and signs tokens with the same keys. It is possible that a token issued for the same audience could be from a different tenant. For example an application could accept users from contoso.onmicrosoft.com but not fabrikam.onmicrosoft.com, both valid tenants. An application that accepts tokens from fabrikam could forward them to the application that accepts tokens for contoso. This boolean only applies to default issuer validation. If IssuerValidator is set, it will be called regardless of whether this property is true or false.</p> <p>The default is true.</p> </li> <li>OIDC__ValidateAudience <p>Validation of the audience, mitigates forwarding attacks. For example, a site that receives a token, could not replay it to another side. A forwarded token would contain the audience of the original site. This boolean only applies to default audience validation. If AudienceValidator is set, it will be called regardless of whether this property is true or false.</p> <p>The default is true.</p> </li> <li>OIDC__ValidateLifetime <p>This boolean only applies to default lifetime validation. If LifetimeValidator is set, it will be called regardless of whether this property is true or false.</p> <p>The default is true.</p> </li> <li>OIDC__ValidateIssuerSigningKey <p>It is possible for tokens to contain the public key needed to check the signature. For example, X509Data can be hydrated into an X509Certificate, which can be used to validate the signature. In these cases it is important to validate the SigningKey that was used to validate the signature. This boolean only applies to default signing key validation. If IssuerSigningKeyValidator is set, it will be called regardless of whether this property is true or false.</p> <p>The default is false.</p> </li> <li>OIDC_ValidateActor <p>If an actor token is detected, whether it should be validated.</p> <p>The default is false.</p> </li> <li>OIDC_ValidateTokenReplay <p>This boolean only applies to default token replay validation. If TokenReplayValidator is set, it will be called regardless of whether this property is true or false.</p> <p>The default is false.</p> </li> </ul>"},{"location":"dev-guide/#device-tags","title":"Device tags","text":"<p>The IoT Hub portal uses some tags to configure the devices. The tags are stored in the Azure IoT Hub in Device Twins.</p> <ul> <li>modelId: The device model ID that is used to retrieve the device model configuration.</li> </ul>"},{"location":"dev-guide/#storage-account","title":"Storage Account","text":"<p>The Storage Account is used to store the device models images. You can use the same Storage Account that is used by the LoRa Key Management Facade. This solution will use tables and blob storage to store its data. There is no need to create the containers, the application will do it for you.</p>"},{"location":"dev-guide/#blob-storage","title":"Blob Storage","text":"<p>The application uses the following blob storage:</p> <ul> <li>device-images: The blob storage that contains the device images.</li> </ul>"},{"location":"dev-guide/#working-with-the-documentation","title":"Working with the documentation","text":"<p>This documentation site is build using Material for MkDocs and Mike.</p> <p><code>docs/main</code> is a detached branch that is locked and only accepts PRs. On PR merge, Github Pages will automatically update the documentation website.</p>"},{"location":"dev-guide/#how-to-update-the-documentation","title":"How to update the documentation","text":"<ol> <li> <p>Checkout the branch that contains the documentation:</p> Bash Session<pre><code>git checkout origin/docs/main\ngit checkout -b docs/&lt;your_branch_name&gt; \n</code></pre> </li> <li> <p>Install dependencies</p> Bash Session<pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Previewing as you write</p> Bash Session<pre><code>mkdocs serve\n</code></pre> </li> <li> <p>PRs are gated by a markdownlint check. You should use markdownlint to lint any new changes on documentation. For example you can use the vs code extension https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint</p> </li> <li>Update the documentation</li> <li>Commit your changes</li> <li>Push your changes to the branch</li> <li>Create a PR</li> </ol>"},{"location":"dev-guide/#customization","title":"Customization","text":"<p>Refer to Material for MkDocs documentations:</p> <ul> <li>https://squidfunk.github.io/mkdocs-material/customization</li> <li>https://squidfunk.github.io/mkdocs-material/setup</li> </ul>"},{"location":"dev-guide/#versioning","title":"Versioning","text":"<p>Mike is used to generate automatically a new documentation version when a release has been published, using ci/cd pipelines.</p> <p>For manual workflows (e.g. delete or retitle an existing version), please refer to Mike documentation</p>"},{"location":"dev-guide/#problem-details","title":"Problem Details","text":"<p>On IoT Hub Portal, we use the library Hellang.Middleware.ProblemDetails which implements RFC7807 to describe issues/problems that occurred on backend.</p>"},{"location":"dev-guide/#handle-a-new-exception-using-problem-details","title":"Handle a new exception using <code>Problem Details</code>","text":"<ul> <li>Create a new exception which extends <code>BaseException</code>. For example see \ud83d\udc49 <code>InternalServerErrorException</code></li> <li>On Startup class, within the instruction <code>services.AddProblemDetails()</code>:     &gt; Your new exception is already catched by the middleware Problem Details because its extends the exception <code>BaseException</code>.     &gt; If you want override the behavior of the middleware when processing your exception, you have to add a new mapping within it.</li> </ul> <p>\ud83d\udca1 You can also map exceptions from dotnet framework and third parties.</p>"},{"location":"dev-guide/#handle-problem-details-exceptions-on-frontend","title":"Handle <code>Problem Details</code> exceptions on frontend","text":"<p>On frontend, http client uses a delegating handler ProblemDetailsHandler to:</p> <ul> <li>Execute the http request and wait the response</li> <li>If the response is not successful:</li> <li>The body of the response is deserialized to <code>ProblemDetailsWithExceptionDetails</code></li> <li>An exception with type <code>ProblemDetailsException</code> (including the error response) is thrown.</li> </ul> <p>On Blazor views, http calls must be catched to capture any exceptions of type <code>ProblemDetailsException</code> to be able to execute any business code to process them.</p> <p>When an http call fails, the user must be notified visually by the application: A component Error has been made to respond to this use case. Below an example on how to:</p> <ul> <li>Catch an ProblemDetailsException when making a http call</li> <li>Delegate the exception to the <code>Error</code> component, so that it can visually warn the user</li> </ul> C#<pre><code>@code {\n    // Inject the reference to the Error component as a cascading parameter\n    [CascadingParameter]\n    public Error Error {get; set;}\n\n    private await Task GetData()\n    {\n        try\n        {\n            // Execute an http request\n        }\n        catch (ProblemDetailsException exception)\n        {\n            // Pass the ProblemDetailsException exception to Error component using its method ProcessProblemDetails()\n            // The Error component will alert the user by showing a (snackbar/dialog) using the content of the exception\n            Error?.ProcessProblemDetails(exception)\n        }\n    }\n}\n</code></pre>"},{"location":"dev-guide/#how-to-install-entity-framework-core","title":"How to install Entity Framework Core","text":"<p>Follow the next step to install EF Core:</p> <ol> <li> <p>Open the terminal and run this command:</p> Bash Session<pre><code>dotnet tool install --global dotnet-ef\n</code></pre> </li> </ol>"},{"location":"dev-guide/#how-to-create-entityframework-migrations-for-postgresql-and-mysql","title":"How to create EntityFramework migrations for PostgreSQL and MySQL","text":"<p>For the project need, we need two database providers which are PostgreSQL and MySQL, which led us to review the architecture set up for the EntityFramework migrations. Here is a diagram showing the two architectures.</p> <pre><code>C4Deployment\n  title Architecture for multiple providers\n\n  Deployment_Node(provider1, \"Provider1\", \"Provider1\"){\n    Container(provider1dbcontextfactory, \"Provider1DbContextFactory\", \"File\", \"\")\n    Container(provider1migrations, \"Provider1Migrations\", \"Folder\", \"\")\n  }\n\n  Deployment_Node(provider2, \"Provider2\", \"Provider2\"){\n    Container(provider2dbcontextfactory, \"Provider2DbContextFactory\", \"File\", \"\")\n    Container(provider2migrations, \"Provider2Migrations\", \"Folder\", \"\")\n  }\n\n  Deployment_Node(dal, \"Infrastructure Layer\", \"Dal\"){\n    Container(dbcontext, \"DbContext\", File, \"\")\n  }\n\n  Rel(provider1dbcontextfactory, dbcontext, \"dependency\", \"\")\n  Rel(provider2dbcontextfactory, dbcontext, \"dependency\", \"\")</code></pre> <p>Follow the next steps to create EF migration:</p> <ol> <li> <p>Go into the Server project folder with terminal</p> Bash Session<pre><code>cd .\\IoTHub.Portal.Server\\\n</code></pre> </li> <li> <p>Execute this command for PostgreSQL provider</p> Bash Session<pre><code>dotnet ef migrations add \"&lt;nameofyourmigration&gt;\" -p ..\\IoTHub.Portal.Postgres\\ -v -- --DbProvider PostgreSQL\n</code></pre> </li> <li> <p>Execute this command for MySQL provider</p> Bash Session<pre><code>dotnet ef migrations add \"&lt;nameofyourmigration&gt;\" -p ..\\IoTHub.Portal.MySql\\ -v -- --DbProvider MySQL\n</code></pre> </li> <li> <p>Open the created migration and follow the following steps:</p> <ol> <li> <p>Move the using directive into the namespace directive</p> </li> <li> <p>Add \"_ =\" before each statement of the Up and Down methods</p> </li> <li> <p>Add the CGI copyright to the top of the file</p> </li> </ol> </li> </ol>"},{"location":"open-api/","title":"Web API Reference","text":""},{"location":"about/credits/","title":"Credits","text":"<ul> <li>Azure IoT Edge LoRaWAN Starter Kit</li> </ul>"},{"location":"about/issues/","title":"Known Issues and Limitations","text":"<p>Refer to Known Issues for known issues, gotchas and limitations.</p>"},{"location":"about/license/","title":"MIT License","text":"<p>Copyright \u00a9 2021 CGI France</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/support/","title":"Support","text":"<p>This is an open source solution. For bugs and issues with the codebase please log an issue in this repo.</p>"},{"location":"dev-guide/conception/diagrams/","title":"Diagrams","text":"<p>In order to better understand the needs of the project, here is a use case diagram regrouping the current use cases of the project.</p>"},{"location":"dev-guide/conception/diagrams/#connected-objects","title":"Connected objects","text":"<pre><code>graph LR\n    A[End user] --&gt; B(Display the list of connected objects)\n    A --&gt; C(Add a connected object)\n    C --&gt;|Extend| B\n    D(Import a list of connected objects) --&gt;|Extend| B\n    E(Download a model) --&gt;|Extend| B\n    F(Export the list of connected objects) --&gt;|Extend| B\n    G(Delete a connected object) --&gt;|Extend| B\n    H(Go to the details of a connected object) --&gt;|Extend| B\n    I(Search for connected objects) --&gt;|Extend| B</code></pre>"},{"location":"dev-guide/conception/diagrams/#connected-object-models","title":"Connected object models","text":"<pre><code>graph LR\n    A[End user] --&gt; J(Display the list of connected object models)\n    A --&gt; K(Add a connected object model)\n    K --&gt;|Extend| J\n    L(Delete a connected object model) --&gt;|Extend| J\n    M(Go to the details of a connected object model) --&gt;|Extend| J</code></pre>"},{"location":"dev-guide/conception/diagrams/#connected-object-configurations","title":"Connected object configurations","text":"<pre><code>graph LR\n    A[End user] --&gt; N(Display the list of connected object configurations)\n    A --&gt; O(Add a connected object configuration)\n    O --&gt;|Extend| N\n    P(Go to the details of a connected object configuration) --&gt; |Extend| N</code></pre>"},{"location":"dev-guide/conception/diagrams/#edge-connected-object-models","title":"Edge connected object models","text":"<pre><code>graph LR\n    A[End user] --&gt; Q(Display the list of Edge connected object models)\n    R(Add an Edge connected object model) --&gt;|Extend| Q\n    S(Delete an Edge connected object model) --&gt;|Extend| Q\n    T(Go to the details of a model of Edge connected object) --&gt;|Extend| Q\n    U(Search for Edge connected object models) --&gt;|Extend| Q</code></pre>"},{"location":"dev-guide/conception/diagrams/#edge-connected-objects","title":"Edge connected objects","text":"<pre><code>graph LR\n    A[End user] --&gt; V(Display the list of Edge connected objects)\n    W(Add an Edge connected object) --&gt;|Extend| V\n    X(Delete an Edge connected object) --&gt;|Extend| V\n    Y(Go to the details of a connected object Edge) --&gt;|Extend| V\n    Z(Search for Edge connected objects) --&gt;|Extend| V</code></pre>"},{"location":"dev-guide/conception/diagrams/#concentrators","title":"Concentrators","text":"<pre><code>graph LR\n    A[End user] --&gt; AA(Display the list of concentrators)\n    AB(Add a concentrator) --&gt;|Extend| AA\n    AC(Delete a concentrator) --&gt;|Extend| AA\n    AD(Go to the details of a concentrator) --&gt;|Extend| AA</code></pre>"},{"location":"dev-guide/conception/diagrams/#tags","title":"Tags","text":"<pre><code>graph LR\n    A[End user] --&gt; AE(Display the list of tags)\n    AF(Add a tag) --&gt;|Extend| AE\n    AG(Delete a tag) --&gt;|Extend| AE</code></pre> <p>Now, here is a diagram representing the multilayer technical architecture of the project.</p> <pre><code>C4Deployment\n    title Multilayer technical architecture\n\n    Deployment_Node(api, \"Server\", \"API\"){\n        Container(controllers, \"Controllers\", \"C#\", \"They are used to route HTTP requests, they call the methods of the services and they return the content of the HTTP response as well as a HTTP code.\")\n        Container(services, \"Services\", \"C#\", \"They are used to define the business logic as to call the methods of the data access layer for example.\")\n    }\n\n    Deployment_Node(bll, \"Application\", \"BLL\"){\n        Container(iservices, \"Services\", C#, \"This package represents the interfaces of the services.\")\n    }\n\n    Deployment_Node(dal, \"Infrastructure\", \"DAL\"){\n        Deployment_Node(uow, \"UnitOfWork\", \"UOW\"){\n            Container(repositories, \"Repositories\", \"C# and EntityFramework\", \"A repository represents all the data management methods of an entity of the project.\")\n        }\n    }\n\n    Deployment_Node(domain, \"Domain\", \"Domain\"){\n        Container(entities, \"Entities\", \"C#\", \"They are used as object representation of tables in a database.\")\n        Container(irepositories, \"Repositories\", \"C#\", \"This package represents the interfaces of the repositories.\")\n    }\n\n    Rel(iservices, services, \"dependency\", \"\")\n    Rel(repositories, services, \"dependency\", \"\")\n    Rel(entities, services, \"dependency\", \"\")\n    Rel(entities, iservices, \"dependency\", \"\")\n    Rel(iservices, repositories, \"dependency\", \"\")\n    Rel(entities, repositories, \"dependency\", \"\")</code></pre> <p>Now, to better understand the technical architecture of the project, here is a class diagram representing it.</p> <pre><code>classDiagram\n    direction LR\n    class AdminController{\n        -String value\n    }\n    class DashboardController{\n        -String value\n    }\n    class DeviceConfigurationsController{\n        -String value\n    }\n    class DeviceModelControllerBase{\n        -String value\n    }\n    class DeviceModelPropertiesController{\n        -String value\n    }\n    class DeviceModelPropertiesControllerBase{\n        -String value\n    }\n    class DeviceModelController{\n        -String value\n    }\n    class DevicesController{\n        -String value\n    }\n    class DevicesControllerBase{\n        -String value\n    }\n    class DeviceTagSettingsController{\n        -String value\n    }\n    class EdgeDevicesController{\n        -String value\n    }\n    class EdgeModelsController{\n        -String value\n    }\n    class IdeasController{\n        -String value\n    }\n    class SettingsController{\n        -String value\n    }\n    class LoRaWANCommandsController{\n        -String value\n    }\n    class LoRaWANConcentratorsController{\n        -String value\n    }\n    class LoRaWANDeviceModelsController{\n        -String value\n    }\n    class LoRaWANDevicesController{\n        -String value\n    }\n    class LoRaWANFrequencyPlansController{\n        -String value\n    }\n    LoRaWANDeviceModelsController --|&gt; DeviceModelsControllerBase\n    LoRaWANDevicesController --|&gt; DevicesControllerBase\n    DeviceModelPropertiesController --|&gt; DeviceModelPropertiesControllerBase\n    DeviceModelsController --|&gt; DeviceModelsControllerBase\n    DevicesController --|&gt; DevicesControllerBase\n    class ConfigService{\n        -String value\n    }\n    class DeviceConfigurationsService{\n        -String value\n    }\n    class DeviceModelPropertiesService{\n        -String value\n    }\n    class DeviceModelService{\n        -String value\n    }\n    class DevicePropertyService{\n        -String value\n    }\n    class DeviceService{\n        -String value\n    }\n    class DeviceServiceBase{\n        -String value\n    }\n    class DeviceTagService{\n        -String value\n    }\n    class EdgeDevicesService{\n        -String value\n    }\n    class EdgeModelService{\n        -String value\n    }\n    class ExternalDeviceService{\n        -String value\n    }\n    class IdeaService{\n        -String value\n    }\n    class LoRaWANCommandService{\n        -String value\n    }\n    class LoRaWANConcentratorService{\n        -String value\n    }\n    class LoRaWanDeviceService{\n        -String value\n    }\n    class SubmitIdeaRequest{\n        -String value\n    }\n    DeviceService --|&gt; DeviceServiceBase\n    LoRaWanDeviceService --|&gt; DeviceServiceBase\n    class IConfigService\n    &lt;&lt;interface&gt;&gt; IConfigService\n    class IDeviceConfigurationsService\n    &lt;&lt;interface&gt;&gt; IDeviceConfigurationsService\n    class IDeviceModelPropertiesService\n    &lt;&lt;interface&gt;&gt; IDeviceModelPropertiesService\n    class IDeviceModelService\n    &lt;&lt;interface&gt;&gt; IDeviceModelService\n    class IDevicePropertyService\n    &lt;&lt;interface&gt;&gt; IDevicePropertyService\n    class IDeviceService\n    &lt;&lt;interface&gt;&gt; IDeviceService\n    class IDeviceTagService\n    &lt;&lt;interface&gt;&gt; IDeviceTagService\n    class IEdgeDevicesService\n    &lt;&lt;interface&gt;&gt; IEdgeDevicesService\n    class IEdgeModelService\n    &lt;&lt;interface&gt;&gt; IEdgeModelService\n    class IExternalDeviceService\n    &lt;&lt;interface&gt;&gt; IExternalDeviceService\n    class IIdeaService\n    &lt;&lt;interface&gt;&gt; IIdeaService\n    class ILoRaWANCommandService\n    &lt;&lt;interface&gt;&gt; ILoRaWANCommandService\n    class ILoRaWANConcentratorService\n    &lt;&lt;interface&gt;&gt; ILoRaWANConcentratorService\n    class ILoRaWanManagementService\n    &lt;&lt;interface&gt;&gt; ILoRaWanManagementService\n    ConfigService ..|&gt; IConfigService\n    DeviceConfigurationsService ..|&gt; IDeviceConfigurationsService\n    DeviceModelPropertiesService ..|&gt; IDeviceModelPropertiesService\n    DeviceModelService ..|&gt; IDeviceModelService\n    DevicePropertyService ..|&gt; IDevicePropertyService\n    DeviceServiceBase ..|&gt; IDeviceService\n    DeviceTagService ..|&gt; IDeviceTagService\n    EdgeDevicesService ..|&gt; IEdgeDevicesService\n    EdgeModelService ..|&gt; IEdgeModelService\n    ExternalDeviceService ..|&gt; IExternalDeviceService\n    IdeaService ..|&gt; IIdeaService\n    LoRaWANCommandService ..|&gt; ILoRaWANCommandService\n    LoRaWANConcentratorService ..|&gt; ILoRaWANConcentratorService\n    class ConcentratorRepository{\n        -String value\n    }\n    class DeviceModelCommandRepository{\n        -String value\n    }\n    class DeviceModelPropertiesRepository{\n        -String value\n    }\n    class DeviceModelRepository{\n        -String value\n    }\n    class DeviceRepository{\n        -String value\n    }\n    class DeviceTagRepository{\n        -String value\n    }\n    class DeviceTagValueRepository{\n        -String value\n    }\n    class EdgeDeviceModelCommandRepository{\n        -String value\n    }\n    class EdgeDeviceModelRepository{\n        -String value\n    }\n    class EdgeDeviceRepository{\n        -String value\n    }\n    class GenericRepository{\n        -String value\n    }\n    class LabelRepository{\n        -String value\n    }\n    class LoRaDeviceTelemetryRepository{\n        -String value\n    }\n    class LorawanDeviceRepository{\n        -String value\n    }\n    class UnitOfWork{\n        -String value\n    }\n    class IConcentratorRepository\n    &lt;&lt;interface&gt;&gt; IConcentratorRepository\n    class IDeviceModelCommandRepository\n    &lt;&lt;interface&gt;&gt; IDeviceModelCommandRepository\n    class IDeviceModelPropertiesRepository\n    &lt;&lt;interface&gt;&gt; IDeviceModelPropertiesRepository\n    class IDeviceModelRepository\n    &lt;&lt;interface&gt;&gt; IDeviceModelRepository\n    class IDeviceRepository\n    &lt;&lt;interface&gt;&gt; IDeviceRepository\n    class IDeviceTagRepository\n    &lt;&lt;interface&gt;&gt; IDeviceTagRepository\n    class IDeviceTagValueRepository\n    &lt;&lt;interface&gt;&gt; IDeviceTagValueRepository\n    class IEdgeDeviceModelCommandRepository\n    &lt;&lt;interface&gt;&gt; IEdgeDeviceModelCommandRepository\n    class IEdgeDeviceModelRepository\n    &lt;&lt;interface&gt;&gt; IEdgeDeviceModelRepository\n    class IEdgeDeviceRepository\n    &lt;&lt;interface&gt;&gt; IEdgeDeviceRepository\n    class ILabelRepository\n    &lt;&lt;interface&gt;&gt; ILabelRepository\n    class ILoRaDeviceTelemetryRepository\n    &lt;&lt;interface&gt;&gt; ILoRaDeviceTelemetryRepository\n    class ILorawanDeviceRepository\n    &lt;&lt;interface&gt;&gt; ILorawanDeviceRepository\n    class IRepository\n    &lt;&lt;interface&gt;&gt; IRepository\n    class IUnitOfWork\n    &lt;&lt;interface&gt;&gt; IUnitOfWork\n    UnitOfWork ..|&gt; IUnitOfWork\n    ConcentratorRepository ..|&gt; IConcentratorRepository\n    ConcentratorRepository --|&gt; GenericRepository\n    DeviceModelCommandRepository ..|&gt; IDeviceModelCommandRepository\n    DeviceModelCommandRepository --|&gt; GenericRepository\n    DeviceModelPropertiesRepository ..|&gt; IDeviceModelPropertiesRepository\n    DeviceModelPropertiesRepository --|&gt; GenericRepository\n    DeviceModelRepository ..|&gt; IDeviceModelRepository\n    DeviceModelRepository --|&gt; GenericRepository\n    DeviceRepository ..|&gt; IDeviceRepository\n    DeviceRepository --|&gt; GenericRepository\n    DeviceTagRepository ..|&gt; IDeviceTagRepository\n    DeviceTagRepository --|&gt; GenericRepository\n    DeviceTagValueRepository ..|&gt; IDeviceTagValueRepository\n    DeviceTagValueRepository --|&gt; GenericRepository\n    EdgeDeviceModelCommandRepository ..|&gt; IEdgeDeviceModelCommandRepository\n    EdgeDeviceModelCommandRepository --|&gt; GenericRepository\n    EdgeDeviceModelRepository ..|&gt; IEdgeDeviceModelRepository\n    EdgeDeviceModelRepository --|&gt; GenericRepository\n    EdgeDeviceRepository ..|&gt; IEdgeDeviceRepository\n    EdgeDeviceRepository --|&gt; GenericRepository\n    GenericRepository ..|&gt; IRepository\n    LabelRepository ..|&gt; ILabelRepository\n    LabelRepository --|&gt; GenericRepository\n    LoRaDeviceTelemetryRepository ..|&gt; ILoRaDeviceTelemetryRepository\n    LoRaDeviceTelemetryRepository --|&gt; GenericRepository\n    LorawanDeviceRepository ..|&gt; ILorawanDeviceRepository\n    LorawanDeviceRepository --|&gt; GenericRepository</code></pre>"},{"location":"dev-guide/migrations/v3-to-v4/","title":"Migrate from v3 to v4","text":"<p>To migrate from v3 to v4 <code>manually</code>, you have to add two new settings to the portal web app. These two settings are required to to pull devices telemetry from the IoT Hub:</p> Name Setting Type Detail <code>IoTHub__EventHub__ConsumerGroup</code> Application setting (Default value <code>iothub-portal</code>) The name of the consumer group used to to pull data from the IoT Hub <code>IoTHub__EventHub__Endpoint</code> Connection string The IotHub Event Hub compatible endpoint <p>Below the required steps for each settings:</p>"},{"location":"dev-guide/migrations/v3-to-v4/#iothub__eventhub__consumergroup","title":"<code>IoTHub__EventHub__ConsumerGroup</code>","text":"<ol> <li>Go to your IoT Hub</li> <li>Navigate to menu Built-in endpoints</li> <li>Create a consumer group with the name <code>iothub-portal</code> </li> <li>Back to the portal web app, add a new application setting with name <code>IoTHub__EventHub__ConsumerGroup</code> and with value <code>iothub-portal</code></li> </ol>"},{"location":"dev-guide/migrations/v3-to-v4/#iothub__eventhub__endpoint","title":"<code>IoTHub__EventHub__Endpoint</code>","text":"<ol> <li>Go to your IoT Hub</li> <li>Navigate to menu Built-in endpoints</li> <li>On the section Event Hub compatible endpoint<ol> <li>Select the shared access policy <code>service</code></li> <li>Copy the value of the event Hub-compatible endpoint   </li> </ol> </li> <li>Back to the portal web app, add a new connection setting with name <code>IoTHub__EventHub__Endpoint</code> and with value the event Hub-compatible endpoint copied earlier</li> </ol> <p>Info</p> <p>You can create your own shared access policy. But the portal needs at least the <code>Service Connect</code> permission</p>"},{"location":"dev-guide/migrations/v4-to-v5/","title":"Migrate from v4 to v5","text":"<p>In this v5, the major change is the integration of AWS in the portal. Some changes have also been made at the portal web app settings.</p>"},{"location":"dev-guide/migrations/v4-to-v5/#aws","title":"AWS","text":"<p>Starting from version 5, the portal now supports <code>AWS</code> integration. To learn how to deploy <code>AWS services</code> using the portal, please refer to the Quick Start for AWS documentation. It provides step-by-step instructions on setting up and deploying AWS resources using the portal's interface.</p>"},{"location":"dev-guide/migrations/v4-to-v5/#azure","title":"Azure","text":"<p>To migrate from v4 to v5 <code>manually</code>, you have to add <code>CloudProvider</code> with <code>Azure</code> as default value. You have to add also <code>Azure__</code> prefix in all setting to the portal web app.  </p> Name Setting Type Detail <code>CloudProvider</code> Application setting (Possible value <code>Azure</code>) The name of the CLoud Provider to run in the portal <code>Azure__LoRaRegionRouterConfig__Url</code> Application setting The Url for LoRa Region Router Configuration <code>Azure__LoRaKeyManagement__Url</code> Application setting The Url for LoRa Key Management <code>Azure__LoRaKeyManagement__Code</code> Application setting The Code for LoRa Key Management <code>Azure__LoRaFeature__Enabled</code> Application setting To enable or disable LoRa Feature <code>Azure__IoTHub__ConnectionString</code> Connection string The IotHub Connection String <code>Azure__IoTHub__EventHub__Endpoint</code> Connection string The IotHub Event Hub compatible endpoint <code>Azure__IoTHub__EventHub__ConsumerGroup</code> Application setting (Default value <code>iothub-portal</code>) The name of the consumer group used to to pull data from the IoT Hub <code>Azure__IoTDPS__ServiceEndpoint</code> Application setting The IotDPS Service Endpoint <code>Azure__IoTDP__LoRaEnrollmentGroup</code> Application setting The name of the IotDPS LoRa Enrollment group <code>Azure__IoTDPS__DefaultEnrollmentGroup</code> Application setting The name of the default IotDPS Enrollment group <code>Azure__IoTDPS__ConnectionString</code> Connection string The IotDPS Connection String"},{"location":"dev-guide/testing/unit-tests-common-practices/","title":"Unit Tests Common Practices","text":""},{"location":"dev-guide/testing/unit-tests-common-practices/#naming-conventions","title":"Naming Conventions","text":""},{"location":"dev-guide/testing/unit-tests-common-practices/#test-class","title":"Test class","text":"<p>The test class should follow the naming convention <code>[ClassUnderTest]Tests</code>.</p> <p>Example: The test class for a class named ProductController should be named <code>ProductControllerTests</code>:</p> C#<pre><code>[TestFixture]\npublic class ProductControllerTests\n{\n    ...\n}\n</code></pre>"},{"location":"dev-guide/testing/unit-tests-common-practices/#test-method","title":"Test method","text":"<p>The test method should follow the naming convention <code>[MethodUnderTest]_[BehaviourToTest]_[ExpectedResult]</code>.</p> <p>Example: A method named GetProduct should be tested to see if it returns an existing product. The name of the test should be <code>GetProduct_ProductExist_ProductReturned</code>:</p> C#<pre><code>[Test]\npublic async Task GetProduct_ProductExist_ProductReturned()\n{\n    ...\n}\n</code></pre>"},{"location":"dev-guide/testing/unit-tests-common-practices/#unit-test-skeleton-three-stepsparts","title":"Unit Test Skeleton: Three Steps/Parts","text":"<p>A unit test should be devided into three steps:</p> <ol> <li>Arrange: The first part where the input/expected data are defined</li> <li>Act: The second part where the behavior under test is executed</li> <li>Assert: The third and final part where assertions are made</li> </ol> <p>These three parts are visually defined with comments so that unit tests are humanly comprehensible:</p> C#<pre><code>[Test]\npublic async Task GetProduct_ProductExist_ProductReturned()\n{\n    // Arrange\n    var productId = Guid.NewGuid().ToString();\n    var expectedProduct = new Product\n    {\n        Id = productId\n    };\n\n    // Act\n    var product = this.productService.GetProduct(productId);\n\n    // Asset\n    _ = product.Should().BeEquivalentTo(expectedProduct);\n}\n</code></pre> <p>Tip</p> <p>On the IoT Hub portal, we use the fluentassertions library for unit tests for natural/human reusable assertions.</p>"},{"location":"dev-guide/testing/unit-tests-common-practices/#mock","title":"Mock","text":"<p>A unit test should only test its assigned layer. Any lower layer that requires/interacts with external resources should be mocked to ensure sure that the unit tests are idempotent.</p> <p>Note</p> <p>Example: We want to implement unit tests for a controller that requires three services. Each service depends on other services/repositories/http clients that need external resources like databases, APIs... Any execution of unit tests that depend on these external resources can be altered (not idempotent) because they depend on the uptime and data of these resources.</p> <p>On the IoT Hub portal, we use the library Moq for mocking within unit tests:</p> C#<pre><code>[TestFixture]\npublic class ProductControllerTests\n{\n    private MockRepository mockRepository;\n    private Mock&lt;IProductRepository&gt; mockProductRepository;\n\n    private IProductService productService;\n\n    [SetUp]\n    public void SetUp()\n    {\n        // Init MockRepository with strict behaviour\n        this.mockRepository = new MockRepository(MockBehavior.Strict);\n        // Init the mock of IProductRepository\n        this.mockProductRepository = this.mockRepository.Create&lt;IProductRepository&gt;();\n        // Init the service ProductService. The object mock ProductRepository is passed the contructor of ProductService\n        this.productService = new ProductService(this.mockProductRepository.Object);\n    }\n\n    [Test]\n    public async Task GetProduct_ProductExist_ProductReturned()\n    {\n        // Arrange\n        var productId = Guid.NewGuid().ToString();\n        var expectedProduct = new Product\n        {\n            Id = productId\n        };\n\n        // Setup mock of GetByIdAsync of the repository ProductRepository to return the expected product when given the correct product id\n        _ = this.mockProductRepository.Setup(repository =&gt; repository.GetByIdAsync(productId))\n                .ReturnsAsync(expectedProduct);\n\n        // Act\n        var product = this.productService.GetProduct(productId);\n\n        // Asset\n        _ = product.Should().BeEquivalentTo(expectedProduct);\n\n        // Assert that all mocks setups have been called\n        _ = MockRepository.VerifyAll();\n    }\n}\n</code></pre>"},{"location":"dev-guide/testing/unit-tests-on-blazor-components/","title":"Unit Tests on Blazor components","text":"<p>Info</p> <p>To test Blazor components on the Iot Hob Portal, we use the library bUnit</p>"},{"location":"dev-guide/testing/unit-tests-on-blazor-components/#how-to-unit-test-component","title":"How to unit test component","text":"<p>Let us assume we have a compoment <code>ProductDetail</code> to test.</p> Example of the content of the component ProductDetail<pre><code>@inject IProductService ProductService\n\n@if(product != null)\n{\n    &lt;p id=\"product-id\"&gt;@product.Id&lt;/p&gt;\n}\n\n@code {\n    [Parameter]\n    public string ProductId { get; set; }\n\n    private Product product;\n\n    protected override async Task OnInitializedAsync()\n    {\n        await GetProduct();\n    }\n\n    private async Task GetProduct()\n    {\n        try\n        {\n            product = await ProductService.GetProduct(ProductId);\n        }\n        catch (ProblemDetailsException exception)\n        {\n            Error?.ProcessProblemDetails(exception);\n        }\n    }\n}\n</code></pre> First you have to a unit test class that extend<pre><code>[TestFixture]\npublic class ProductDetailTests : BlazorUnitTest\n{\n}\n</code></pre> <p>Info</p> <p>The class <code>BlazorUnitTest</code> provides helpers/test context dedicated for unit tests for the blazor component. It also avoids code duplication of unit test classes.</p> Override the method Setup<pre><code>[TestFixture]\npublic class ProductDetailTests : BlazorUnitTest\n{\n    public override void Setup()\n    {\n        // Don't forget the method base.Setup() to initialize existing helpers\n        base.Setup();\n    }\n}\n</code></pre> Setup the mockup of the service IProductService<pre><code>[TestFixture]\npublic class ProductDetailTests : BlazorUnitTest\n{\n    // Declare the mock of IProductService\n    private Mock&lt;IProductService&gt; productServiceMock;\n\n    public override void Setup()\n    {\n        base.Setup();\n\n        // Intialize the mock of IProductService\n        this.productServiceMock = MockRepository.Create&lt;IProductService&gt;();\n\n        // Add the mock of IProductService as a singleton for resolution \n        _ = Services.AddSingleton(this.productServiceMock.Object);\n    }\n}\n</code></pre> <p>Info</p> <p>After configuring the test class setup, you can start implementing unit tests.</p> <p>Below is an example of a a unit test that checks whether the GetProduct method of the serivce ProductService service was called after the component was initialized:</p> C#<pre><code>[TestFixture]\npublic class ProductDetailTests : BlazorUnitTest\n{\n    ...\n\n    [Test]\n    public void OnInitializedAsync_GetProduct_ProductIsRetrieved()\n    {\n        // Arrange\n        var expectedProduct = Fixture.Create&lt;Product&gt;();\n\n        // Setup mock of GetProduct of the service ProductService\n        _ = this.productServiceMock.Setup(service =&gt; service.GetProduct(expectedProduct.Id))\n            .ReturnsAsync(expectedProduct);\n\n        // Act\n        // Render the component ProductDetail with the required ProductId parameter\n        var cut = RenderComponent&lt;ProductDetail&gt;(ComponentParameter.CreateParameter(\"ProductId\", expectedProduct.Id));\n        // You can wait for a specific element to be rendered before assertions using a css selector, for example the DOM element with id product-id\n        _ = cut.WaitForElement(\"#product-id\");\n\n        // Assert\n        // Assert that all mocks setups have been called\n        cut.WaitForAssertion(() =&gt; MockRepository.VerifyAll());\n    }\n}\n</code></pre> <p>Tip</p> <p><code>WaitForAssertion</code> is useful in asserting asynchronous changes: It will blocks and waits in a test method until the specified assertion action does not throw an exception, or until the timeout is reached (the default timeout is one second).  Assertion of asynchronous changes</p> <p>Tip</p> <p>Within unit tests on Blazor components, you can interact with HTML DOM and query rendered HTMLelements (buttons, div...) by using CSS selectors (id, class...)  Lean more about CSS selectors</p>"},{"location":"dev-guide/testing/unit-tests-on-blazor-components/#how-to-unit-test-a-component-requiring-an-external-component","title":"How to unit test a component requiring an external component","text":"<p>Some components proposed by MudBlazor (MudAutocomplete, MudSelect...) use another component <code>MudPopoverProvider</code> to display elements. If in a unit test that uses these MudBlazor components, the <code>MudPopoverProvider</code> component is not rendered, the interactions with these components are restricted.</p> <p>Let us start with the following example:</p> Example of the content of the component SearchState<pre><code>&lt;MudAutocomplete T=\"string\" Label=\"US States\" @bind-Value=\"selectedState\" SearchFunc=\"@Search\" /&gt;\n\n@code {\n    private string selectedState;\n    private string[] states =\n    {\n        \"Alabama\", \"Colorado\", \"Missouri\", \"Wisconsin\"\n    }\n\n    private async Task&lt;IEnumerable&lt;string&gt;&gt; Search(string value)\n    {\n        // In real life use an asynchronous function for fetching data from an api.\n        await Task.Delay(5);\n\n        // if text is null or empty, show complete list\n        if (string.IsNullOrEmpty(value)) \n            return states;\n        return states.Where(x =&gt; x.Contains(value, StringComparison.InvariantCultureIgnoreCase));\n    }\n}\n</code></pre> <p>We want to test the search when a user interacts with the <code>MudAutocomplete</code> component to search for the state <code>Wisconsin</code>:</p> C#<pre><code>[TestFixture]\npublic class SearchStateTests : BlazorUnitTest\n{\n    ...\n\n    [Test]\n    public void Search_UserSearchAndSelectState_StateIsSelected()\n    {\n        // Arrange\n        var userQuery = \"Wis\";\n\n        // First render MudPopoverProvider component\n        var popoverProvider = RenderComponent&lt;MudPopoverProvider&gt;();\n        // Second, rendrer the component SearchState (under unit test)\n        var cut = RenderComponent&lt;SearchState&gt;();\n\n        // Find the MudAutocomplete component within SearchState component\n        var autocompleteComponent = cut.FindComponent&lt;MudAutocomplete&lt;string&gt;&gt;();\n\n        // Fire click event on, \n        autocompleteComponent.Find(\"input\").Click();\n        autocompleteComponent.Find(\"input\").Input(userQuery);\n\n        // Wait until the count of element in the list rendred on the component MudPopoverProvider is equals to one\n        popoverProvider.WaitForAssertion(() =&gt; popoverProvider.FindAll(\"div.mud-list-item\").Count.Should().Be(1));\n\n        // Act\n        // Get the only element present on the list\n        var stateElement = popoverProvider.Find(\"div.mud-list-item\");\n        // Fire click event on the element\n        stateElement.Click();\n\n        // Assert\n        // Check if the MudAutocomplete compoment has been closed after the click event\n        cut.WaitForAssertion(() =&gt; autocompleteComponent.Instance.IsOpen.Should().BeFalse());\n        ...\n    }\n}\n</code></pre>"}]}